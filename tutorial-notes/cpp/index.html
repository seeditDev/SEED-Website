<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Programming Notes</title>
    <link rel="icon" href="https://raw.githubusercontent.com/seeditDev/SEED-Website/f3cee9002410a00df4da7bea636ac9fbc4c312ca/Plugins/SEED_Logo.webp" type="image/webp">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }
        header {
            background: #35424a;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        header img {
            width: 50px;
            vertical-align: middle;
        }
        header h1 {
            display: inline;
            font-size: 1.8rem;
            margin-left: 10px;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        .section {
            margin: 20px 0;
        }
        .section h2 {
            color: #35424a;
        }
        .section code {
            background-color: #f8f8f8;
            padding: 5px;
            border: 1px solid #ddd;
        }
        .example {
            background-color: #f8f8f8;
            padding: 10px;
            border: 1px solid #ddd;
            margin-top: 10px;
        }
        footer {
            text-align: center;
            padding: 10px 0;
            background: #35424a;
            color: #fff;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <header>
        <img src="https://raw.githubusercontent.com/seeditDev/SEED-Website/f3cee9002410a00df4da7bea636ac9fbc4c312ca/Plugins/SEED_Logo.webp" alt="Logo">
        <h1>C++ Programming Notes</h1>
    </header>

    <div class="container">
        <!-- Introduction to C++ Programming -->
        <div class="section" id="intro-to-cpp">
    <h2>Introduction to C++ Programming</h2>
    <p>C++ is a powerful, efficient, and versatile programming language that has stood the test of time. Developed by Bjarne Stroustrup in the early 1980s, C++ builds upon the foundation of the C programming language by introducing object-oriented features, making it a multi-paradigm language that supports both procedural and object-oriented programming (OOP) techniques.</p>

    <h3>Why C++?</h3>
    <p>C++ is widely used in software development due to its performance and flexibility. It allows for fine control over system resources, making it suitable for resource-intensive applications like video games, system software, operating systems, and embedded systems. The language also plays a key role in areas where performance is crucial, such as high-frequency trading, graphics rendering, and simulations.</p>
    <p>C++ is not just another programming language; it provides a foundation for understanding programming concepts like memory management, pointers, data abstraction, and polymorphism, which are often not explicitly covered in higher-level languages.</p>

    <h3>How C++ Differs from C</h3>
    <p>While C and C++ share many common elements, C++ is an extension of C that adds object-oriented programming features. Hereâ€™s a breakdown of the key differences:</p>
    <ul>
        <li><strong>Object-Oriented Programming (OOP):</strong> C++ supports OOP, a paradigm that allows developers to model real-world entities using classes and objects. C, on the other hand, is purely procedural and lacks built-in support for objects, inheritance, and polymorphism.</li>
        <li><strong>Classes and Objects:</strong> In C++, you can define custom types (classes) and create instances of those types (objects). These features are essential in modern software development and provide better modularity and code reuse. C does not have these capabilities.</li>
        <li><strong>Function Overloading:</strong> C++ allows you to define multiple functions with the same name, but different parameter types. This feature makes the code more readable and reduces the need for unique function names. C does not support function overloading.</li>
        <li><strong>Memory Management:</strong> While both C and C++ allow manual memory management using pointers, C++ introduces features like constructors, destructors, and the <code>new</code> and <code>delete</code> operators, which help manage memory more safely and efficiently than in C.</li>
        <li><strong>STL (Standard Template Library):</strong> C++ comes with the Standard Template Library (STL), a collection of template classes and functions that make it easier to work with common data structures like vectors, stacks, queues, lists, and more. C lacks such an extensive library and often requires custom implementations of these data structures.</li>
    </ul>

    <h3>Key Features of C++</h3>
    <p>Some of the core features that set C++ apart from other languages, including C, are:</p>
    <ul>
        <li><strong>Object-Oriented Programming:</strong> Classes, objects, inheritance, polymorphism, encapsulation, and abstraction help developers model complex systems in a more structured and maintainable way.</li>
        <li><strong>Low-Level Memory Manipulation:</strong> C++ allows direct memory manipulation through pointers, providing fine control over system resources.</li>
        <li><strong>Templates:</strong> C++ introduces templates, enabling the development of generic functions and classes that can work with any data type. This feature improves code reusability and reduces redundancy.</li>
        <li><strong>Exception Handling:</strong> C++ includes a built-in exception handling mechanism using <code>try, catch, throw</code> blocks, which helps manage runtime errors and allows for more robust and fault-tolerant applications.</li>
        <li><strong>RAII (Resource Acquisition Is Initialization):</strong> A programming idiom in C++ that helps manage resources like memory, file handles, and database connections through the use of destructors and automatic resource management.</li>
    </ul>

    <h3>How C++ Is Used</h3>
    <p>C++ is used in a wide variety of applications, ranging from low-level system programming to high-performance computing:</p>
    <ul>
        <li><strong>System Software:</strong> C++ is frequently used in the development of operating systems and device drivers due to its low-level capabilities.</li>
        <li><strong>Game Development:</strong> Many popular game engines (e.g., Unreal Engine) are written in C++ because of its performance and direct access to hardware.</li>
        <li><strong>Embedded Systems:</strong> C++ is widely used in embedded systems programming, where low-level hardware control and efficient memory usage are essential.</li>
        <li><strong>Scientific and Financial Computing:</strong> C++ is commonly used for simulations, data processing, and other computationally intensive tasks where performance is crucial.</li>
        <li><strong>High-Performance Applications:</strong> Applications requiring real-time processing, like video rendering or 3D graphics, often use C++ for its efficiency and speed.</li>
    </ul>

    <h3>Basic Structure of a C++ Program</h3>
    <p>A basic C++ program follows this general structure:</p>
    <pre>
#include <iostream>  // Preprocessor directive to include input-output stream

using namespace std;  // Use the standard namespace

int main() {  // Main function - execution starts here
    // Code statements go here
    cout << "Hello, World!" << endl;  // Output statement
    return 0;  // Indicate successful program termination
}
    </pre>
    <p>This structure consists of:</p>
    <ul>
        <li><strong>Preprocessor Directives:</strong> <code>#include</code> statements to include libraries that provide additional functionality (e.g., input-output handling).</li>
        <li><strong>Namespaces:</strong> The <code>using namespace std;</code> directive allows the program to use standard library features without needing to prefix them with <code>std::</code>.</li>
        <li><strong>Functions:</strong> A C++ program starts execution from the <code>main()</code> function, which is required in every C++ program.</li>
        <li><strong>Statements:</strong> Code statements like <code>cout</code> are used for output, and <code>return</code> is used to indicate the end of the program.</li>
    </ul>
</div>


<div class="section" id="cpp-headerfiles">
    <h2>C++ Header Files</h2>
    <p>In C++, header files are essential components that provide function declarations, class definitions, constants, and other definitions that can be shared across multiple files in a project. A header file typically ends with a `.h` or `.hpp` extension.</p>

    <h3>1. <code>#include <iostream></code></h3>
    <p>The <code>iostream</code> header file is one of the most commonly used files in C++ and is used for input and output operations. It defines the <code>cin</code>, <code>cout</code>, <code>cerr</code>, and <code>clog</code> objects for handling input and output operations.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <iostream>  // Includes the iostream library

int main() {
    std::cout << "Hello, World!" << std::endl;  // Output to the console
    return 0;
}
    </pre>

    <h3>2. <code>#include <cmath></code></h3>
    <p>The <code>cmath</code> header file provides functions to perform mathematical operations like square root, trigonometric calculations, logarithms, and others.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <cmath>  // Includes mathematical functions

int main() {
    double result = std::sqrt(16);  // Calculates the square root of 16
    std::cout << "Square root of 16 is: " << result << std::endl;
    return 0;
}
    </pre>

    <h3>3. <code>#include <cstdlib></code></h3>
    <p>The <code>cstdlib</code> header file provides functions for performing general utility functions like memory allocation, process control, and conversions. It includes functions like <code>malloc</code>, <code>free</code>, <code>exit</code>, <code>atoi</code>, and more.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <cstdlib>  // Includes utility functions like malloc and exit

int main() {
    int num = std::atoi("100");  // Converts string to integer
    std::cout << "Converted number is: " << num << std::endl;
    return 0;
}
    </pre>

    <h3>4. <code>#include <string></code></h3>
    <p>The <code>string</code> header file is used for manipulating strings in C++. It provides the <code>std::string</code> class that allows you to create, manipulate, and perform operations on strings.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <string>  // Includes string handling functions

int main() {
    std::string str = "Hello";
    str += " World!";  // Concatenates strings
    std::cout << str << std::endl;
    return 0;
}
    </pre>

    <h3>5. <code>#include <vector></code></h3>
    <p>The <code>vector</code> header file provides the <code>std::vector</code> class, which is a dynamic array that can grow or shrink in size during runtime. It provides many functions to insert, remove, and access elements in the vector.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <vector>  // Includes the vector class

int main() {
    std::vector<int> vec = {1, 2, 3, 4};
    vec.push_back(5);  // Adds an element at the end
    std::cout << "Last element: " << vec.back() << std::endl;
    return 0;
}
    </pre>

    <h3>6. <code>#include <algorithm></code></h3>
    <p>The <code>algorithm</code> header file provides functions for performing operations like sorting, searching, and manipulating data structures. Functions such as <code>sort</code>, <code>reverse</code>, and <code>find</code> are defined in this header.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <algorithm>  // Includes sorting and searching algorithms

int main() {
    std::vector<int> vec = {3, 1, 4, 1, 5};
    std::sort(vec.begin(), vec.end());  // Sorts the vector
    std::cout << "Sorted vector: ";
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
    </pre>

    <h3>7. <code>#include <ctime></code></h3>
    <p>The <code>ctime</code> header file provides functions for manipulating and working with date and time. It includes functions like <code>time()</code>, <code>localtime()</code>, <code>strftime()</code>, and more.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <ctime>  // Includes date and time manipulation functions

int main() {
    std::time_t current_time = std::time(nullptr);  // Gets current time
    std::cout << "Current time: " << std::ctime(&current_time);  // Outputs the current time
    return 0;
}
    </pre>

    <h3>8. <code>#include <fstream></code></h3>
    <p>The <code>fstream</code> header file provides facilities for file input and output. You can use the <code>ifstream</code> class to read from files and the <code>ofstream</code> class to write to files.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <fstream>  // Includes file handling functions

int main() {
    std::ofstream out_file("output.txt");  // Creates and opens a file for writing
    out_file << "This is a file output." << std::endl;
    out_file.close();  // Closes the file
    return 0;
}
    </pre>

    <h3>9. <code>#include <map></code></h3>
    <p>The <code>map</code> header file defines the <code>std::map</code> container, which is a sorted associative container that stores key-value pairs. It provides efficient lookup, insertion, and deletion of key-value pairs.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <map>  // Includes map class

int main() {
    std::map<int, std::string> my_map;
    my_map[1] = "Apple";
    my_map[2] = "Banana";
    my_map[3] = "Cherry";

    for (auto& pair : my_map) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    return 0;
}
    </pre>

    <h3>10. <code>#include <set></code></h3>
    <p>The <code>set</code> header file defines the <code>std::set</code> container, which stores unique elements in a sorted order. It is an associative container that ensures no duplicate values.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <set>  // Includes set class

int main() {
    std::set<int> my_set = {2, 4, 6, 8, 10};
    my_set.insert(12);  // Adds an element to the set

    for (int num : my_set) {
        std::cout << num << " ";  // Prints elements in sorted order
    }
    std::cout << std::endl;
    return 0;
}
    </pre>

    <h3>11. <code>#include <sstream></code></h3>
    <p>The <code>sstream</code> header file provides classes like <code>std::stringstream</code> that allow you to perform input and output operations on strings.</p>
    <p><strong>Example:</strong></p>
    <pre>
#include <sstream>  // Includes string stream classes

int main() {
    std::stringstream ss;
    ss << "The answer is: " << 42;  // Write data to the string stream
    std::string result = ss.str();  // Get the string from the stream
    std::cout << result << std::endl;
    return 0;
}
    </pre>

</div>

<div class="section" id="cpp-main-function">
    <h2>Main Function in C and C++</h2>
    <p>The <code>main()</code> function is the entry point of every C and C++ program. It is the starting point where the execution of the program begins. No matter how complex the program is, execution always begins from the <code>main()</code> function. The main function is necessary for the program to run.</p>

    <h3>1. Syntax of <code>main()</code> Function</h3>
    <p>The syntax of the <code>main()</code> function is straightforward and has two primary forms:</p>
    <pre>
int main() {  // Standard declaration, returns an integer
    // Code statements
    return 0;  // Optional return statement (indicates successful execution)
}
    </pre>
    <p>Or it can also be declared with command-line arguments:</p>
    <pre>
int main(int argc, char *argv[]) {  // Accepts command-line arguments
    // Code statements
    return 0;
}
    </pre>

    <h3>2. Purpose of <code>main()</code> Function</h3>
    <p>The <code>main()</code> function serves the following purposes:</p>
    <ul>
        <li><strong>Starting Point:</strong> The execution of the program always begins with the <code>main()</code> function.</li>
        <li><strong>Return Status:</strong> The function typically returns an integer value. By convention, a return value of 0 indicates successful execution, while non-zero values indicate errors.</li>
        <li><strong>Handles Command-Line Arguments:</strong> If declared with <code>argc</code> (argument count) and <code>argv</code> (argument vector), it allows the program to accept command-line inputs.</li>
    </ul>

    <h3>3. Return Type of <code>main()</code></h3>
    <p>The <code>main()</code> function usually returns an integer to indicate the program's execution status:</p>
    <ul>
        <li><code>return 0;</code> - Indicates that the program has executed successfully.</li>
        <li><code>return non-zero value;</code> - Indicates an error or abnormal termination.</li>
    </ul>

    <h3>4. Command-Line Arguments</h3>
    <p>The main function can accept command-line arguments, which are passed to the program when it is executed from the command line. These arguments are defined in the <code>main()</code> function as:</p>
    <pre>
int main(int argc, char *argv[]) {
    // Code statements
}
    </pre>
    <p>Where:</p>
    <ul>
        <li><code>argc</code> - The number of arguments passed to the program (including the program's name).</li>
        <li><code>argv</code> - An array of strings (character pointers) representing the arguments passed to the program. The first element <code>argv[0]</code> is the name of the program, and the subsequent elements are the command-line arguments.</li>
    </ul>

    <h3>5. Example of Using Command-Line Arguments</h3>
    <p>Here is an example of a program that accepts command-line arguments:</p>
    <pre>
#include <iostream>

int main(int argc, char *argv[]) {
    std::cout << "Number of arguments: " << argc << std::endl;

    std::cout << "Arguments passed:" << std::endl;
    for (int i = 0; i < argc; ++i) {
        std::cout << "Argument " << i << ": " << argv[i] << std::endl;
    }

    return 0;
}
    </pre>
    <p>If the program is executed like this:</p>
    <pre>
$ ./program arg1 arg2 arg3
    </pre>
    <p>The output will be:</p>
    <pre>
Number of arguments: 4
Arguments passed:
Argument 0: ./program
Argument 1: arg1
Argument 2: arg2
Argument 3: arg3
    </pre>

    <h3>6. Special Variations of <code>main()</code> Function</h3>
    <p>There are a few special variations of the <code>main()</code> function that are sometimes used in advanced applications:</p>
    <ul>
        <li><strong><code>int main(void)</code>:</strong> This is a more strict version, often used in C. It signifies that the program accepts no arguments.</li>
        <li><strong><code>int main(int argc, char **argv)</code>:</strong> This is another valid form for passing command-line arguments. It uses a double pointer for arguments instead of a pointer array.</li>
    </ul>

    <h3>7. A Basic Example Program</h3>
    <p>Here is a simple C++ program with the <code>main()</code> function:</p>
    <pre>
#include <iostream>

int main() {
    std::cout << "Welcome to C++ Programming!" << std::endl;  // Output to console
    return 0;  // Indicates successful execution
}
    </pre>
    <p>This program will output the text "Welcome to C++ Programming!" when run.</p>

    <h3>8. Exit Status of <code>main()</code></h3>
    <p>The exit status of the <code>main()</code> function can be used to communicate success or failure to the operating system or calling process:</p>
    <ul>
        <li><strong>0:</strong> Success</li>
        <li><strong>Non-zero:</strong> Indicates some error occurred (specific codes for specific errors can be returned).</li>
    </ul>

    <p>In many C++ programs, the return value of <code>main()</code> is often ignored, but it is still good practice to return a value that represents the program's execution status.</p>

</div>

<div class="section" id="cpp-variables">
    <h2>Variables in C and C++</h2>
    <p>Variables are fundamental in any programming language, including C and C++. They act as containers for storing data, which can then be manipulated and accessed throughout the program.</p>

    <h3>1. What is a Variable?</h3>
    <p>A variable is a named storage location in memory that holds a value which can be modified during program execution. Each variable has a specific type, which determines the kind of data it can hold. For example, an integer variable can hold integer values, and a floating-point variable can hold decimal values.</p>

    <h3>2. Syntax for Declaring Variables</h3>
    <p>The basic syntax for declaring a variable in C and C++ is as follows:</p>
    <pre>
<data_type> <variable_name>;
    </pre>
    <p>Here, <code>data_type</code> represents the type of data the variable will hold (like int, float, char, etc.), and <code>variable_name</code> is the name given to the variable.</p>

    <h3>3. Types of Variables</h3>
    <p>C and C++ support various types of variables. The main categories are:</p>
    <ul>
        <li><strong>Primitive Data Types:</strong> These include integer types (<code>int</code>), floating-point types (<code>float</code>, <code>double</code>), and character types (<code>char</code>).</li>
        <li><strong>Derived Data Types:</strong> These are based on primitive data types, such as arrays, pointers, structures, and unions.</li>
        <li><strong>Enumerated Types:</strong> These allow you to define variables that can take on a limited set of values (using <code>enum</code>).</li>
        <li><strong>Void Type:</strong> A special type representing the absence of data. It is used in function declarations when no value is returned (e.g., <code>void function_name()</code>).</li>
    </ul>

    <h3>4. Examples of Variable Declarations</h3>
    <p>Here are a few examples of declaring variables in C and C++:</p>
    <pre>
int num;         // Declares an integer variable
float pi;        // Declares a floating-point variable
char letter;     // Declares a character variable
double value;    // Declares a double precision variable
    </pre>
    <p>You can also initialize a variable at the time of declaration:</p>
    <pre>
int num = 10;       // Integer initialized with a value
float pi = 3.14;    // Float initialized with a value
char letter = 'A';  // Character initialized with a value
double value = 99.99;  // Double initialized with a value
    </pre>

    <h3>5. Types of Variable Initialization</h3>
    <p>There are several ways to initialize variables in C and C++:</p>
    <ul>
        <li><strong>Default Initialization:</strong> If you donâ€™t initialize a variable at the time of declaration, it may have a garbage value (unpredictable). For example:</li>
        <pre>
int num;  // num is uninitialized and has a garbage value
        </pre>
        
        <li><strong>Initialization with a Value:</strong> A variable can be initialized directly with a specific value:</li>
        <pre>
int num = 5;  // num is initialized with 5
        </pre>
        
        <li><strong>Initialization Using Constructor (C++ only):</strong> In C++, classes can have constructors to initialize class variables:</li>
        <pre>
class MyClass {
public:
    int num;
    MyClass(int x) { num = x; }  // Constructor to initialize num
};
        </pre>
    </ul>

    <h3>6. Local and Global Variables</h3>
    <p>Variables in C and C++ can be classified as either local or global:</p>
    <ul>
        <li><strong>Local Variables:</strong> These are declared inside functions or blocks and can only be accessed within the function or block where they are declared. They are destroyed once the function exits.</li>
        <pre>
void myFunction() {
    int num = 10;  // Local variable
    std::cout << num;  // Can be accessed here
}
        </pre>

        <li><strong>Global Variables:</strong> These are declared outside of all functions, typically at the top of the program. Global variables can be accessed by all functions within the program.</li>
        <pre>
int num = 20;  // Global variable

void myFunction() {
    std::cout << num;  // Can be accessed here too
}
        </pre>
    </ul>

    <h3>7. Static Variables</h3>
    <p>In both C and C++, a variable can be declared as <code>static</code>. A static variable maintains its value between function calls and is only initialized once.</p>
    <pre>
void counter() {
    static int count = 0;  // Static variable
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    counter();  // Output: Count: 1
    counter();  // Output: Count: 2
}
    </pre>
    <p>In this example, the static variable <code>count</code> retains its value across function calls.</p>

    <h3>8. Constants and Constants in C++</h3>
    <p>Constants are variables whose values cannot be modified after initialization. You can declare constants in C using <code>const</code> keyword, or use <code>#define</code> in C. C++ provides the <code>const</code> keyword and <code>constexpr</code> for more advanced cases.</p>
    <pre>
const int MAX = 100;  // Constant variable in C/C++
#define PI 3.14  // Preprocessor constant in C
    </pre>
    
    <h3>9. Variable Scope</h3>
    <p>The scope of a variable defines where it can be accessed within the program. In C and C++, the most common scopes are:</p>
    <ul>
        <li><strong>Block Scope:</strong> Variables declared inside a block (e.g., inside a function) are only accessible within that block.</li>
        <li><strong>Function Scope:</strong> Local variables have function scope, which means they are accessible only within the function they are declared.</li>
        <li><strong>File Scope:</strong> Global variables are accessible throughout the file after their declaration.</li>
        <li><strong>Class Scope (C++):</strong> In C++, variables inside classes are class-scoped and are accessible only through objects or the class itself.</li>
    </ul>

    <h3>10. Example of Variable Usage</h3>
    <p>Here's an example program demonstrating different types of variables:</p>
    <pre>
#include <iostream>
using namespace std;

int globalVar = 100;  // Global variable

void example() {
    int localVar = 50;  // Local variable
    static int staticVar = 0;  // Static variable

    staticVar++;
    cout << "Local Variable: " << localVar << endl;
    cout << "Static Variable: " << staticVar << endl;
    cout << "Global Variable: " << globalVar << endl;
}

int main() {
    example();
    example();  // Static variable retains its value across calls
    return 0;
}
    </pre>
    <p>Output:</p>
    <pre>
Local Variable: 50
Static Variable: 1
Global Variable: 100
Local Variable: 50
Static Variable: 2
Global Variable: 100
    </pre>

</div>


        <!-- C++ Data Types -->
        <div class="section" id="cpp-datatypes">
    <h2>Data Types in C and C++</h2>
    <p>Data types are essential in C and C++ programming. They define the type of data a variable can hold, whether it's an integer, a floating-point number, or a character. Understanding the different data types available is critical for effective programming and memory management.</p>

    <h3>1. Primitive Data Types</h3>
    <p>Primitive data types are the most basic types in C and C++. They represent simple values and are the building blocks for more complex data types.</p>

    <h4>1.1 Integer Types</h4>
    <p>Integer types are used to store whole numbers (without decimal points).</p>
    <ul>
        <li><strong>int</strong>: Represents a standard integer.</li>
        <pre>int num = 10;</pre>
        <li><strong>short</strong>: A smaller integer type. It uses less memory but can represent smaller ranges.</li>
        <pre>short s = 32767;</pre>
        <li><strong>long</strong>: A larger integer type. It can store bigger numbers than the regular <code>int</code>.</li>
        <pre>long l = 123456789;</pre>
        <li><strong>long long</strong>: A very large integer type, usually used when <code>long</code> is not enough.</li>
        <pre>long long ll = 12345678901234;</pre>
        <li><strong>unsigned</strong>: A variant of the above types, where only non-negative values are allowed.</li>
        <pre>unsigned int u = 1000;</pre>
    </ul>
    <p>The size of these integer types depends on the system architecture (32-bit vs 64-bit). For example, a 32-bit system may allocate 4 bytes for an <code>int</code>, while a 64-bit system may allocate 8 bytes.</p>

    <h4>1.2 Floating-Point Types</h4>
    <p>Floating-point types are used to store numbers that have fractional parts (decimals).</p>
    <ul>
        <li><strong>float</strong>: Used to store single-precision floating-point numbers (usually 4 bytes).</li>
        <pre>float f = 3.14;</pre>
        <li><strong>double</strong>: Used for double-precision floating-point numbers (usually 8 bytes).</li>
        <pre>double d = 3.14159265359;</pre>
        <li><strong>long double</strong>: A higher precision floating-point type with more storage space (usually 12 or 16 bytes).</li>
        <pre>long double ld = 3.14159265358979323846;</pre>
    </ul>

    <h4>1.3 Character Type</h4>
    <p>Character types are used to store single characters. These are stored as numeric codes, with ASCII or Unicode being the most common encoding systems.</p>
    <ul>
        <li><strong>char</strong>: Stores a single character (usually 1 byte).</li>
        <pre>char ch = 'A';</pre>
        <li><strong>unsigned char</strong>: Similar to <code>char</code>, but only stores non-negative values (0 to 255).</li>
        <pre>unsigned char uch = 255;</pre>
    </ul>

    <h4>1.4 Boolean Type</h4>
    <p>The boolean data type is used to store logical values, such as <code>true</code> or <code>false</code>. C does not have a native boolean type, but C++ supports <code>bool</code>.</p>
    <ul>
        <li><strong>bool</strong> (C++ only): Represents a boolean value, either <code>true</code> or <code>false</code>.</li>
        <pre>bool isTrue = true;</pre>
    </ul>

    <h3>2. Derived Data Types</h3>
    <p>Derived data types are built from primitive data types. They are more complex data types that allow you to store multiple values or references to other variables.</p>

    <h4>2.1 Arrays</h4>
    <p>An array is a collection of elements of the same data type stored in contiguous memory locations.</p>
    <pre>int arr[5] = {1, 2, 3, 4, 5};</pre>
    <p>Arrays can be of any data type and can store multiple elements (e.g., an array of integers or an array of characters).</p>

    <h4>2.2 Pointers</h4>
    <p>A pointer is a variable that stores the memory address of another variable. It allows indirect access to other variables.</p>
    <pre>int num = 10;
int *ptr = &num;</pre>
    <p>Pointers are extensively used in C and C++ for dynamic memory allocation, data structures (linked lists, trees), and function arguments.</p>

    <h4>2.3 Structures</h4>
    <p>A structure is a user-defined data type that allows grouping of different data types into a single unit.</p>
    <pre>
struct Person {
    char name[50];
    int age;
};
struct Person p1;
p1.age = 25;
</pre>
    <p>Structures are useful when you need to combine different data types under one entity (e.g., storing information about a person).</p>

    <h4>2.4 Unions</h4>
    <p>A union is similar to a structure, but in a union, all members share the same memory location, meaning they cannot hold different values at the same time.</p>
    <pre>
union Data {
    int i;
    float f;
};
union Data data;
data.i = 10;
data.f = 3.14;
</pre>
    <p>Unions are often used when you need to store different types of data, but only one type of data will be used at a time.</p>

    <h3>3. Enumerated Data Types (enum)</h3>
    <p>An enumerated data type allows you to define a variable that can only take a specific set of values. These values are given symbolic names that improve code readability.</p>
    <pre>
enum Day {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};
Day today = Wednesday;
</pre>
    <p>Enumerations are often used to represent states, choices, or options in a program.</p>

    <h3>4. Void Data Type</h3>
    <p>The <code>void</code> data type is a special type that represents the absence of a value. It is used in functions to specify that they donâ€™t return a value, or to indicate that a pointer can point to any data type.</p>
    <pre>
void function() {
    // No return value
}
</pre>
    <p>In C and C++, <code>void*</code> is a generic pointer type that can point to any data type.</p>

    <h3>5. C++ Specific Data Types</h3>
    <p>C++ provides some additional data types and features not available in C:</p>
    <ul>
        <li><strong>std::string</strong>: A C++ specific data type that represents a string of characters.</li>
        <pre>std::string name = "John";</pre>
        <li><strong>class</strong>: A class is a blueprint for objects and is used to define complex data types in C++.</li>
        <pre>
class Person {
public:
    int age;
    std::string name;
};
        </pre>
    </ul>

    <h3>6. Type Modifiers in C and C++</h3>
    <p>Type modifiers in C and C++ allow you to modify the size or range of data types. They are used in conjunction with the basic data types to extend their functionality.</p>
    <ul>
        <li><strong>short</strong>: Modifies integer types to take up less memory.</li>
        <li><strong>long</strong>: Modifies integer types to take up more memory.</li>
        <li><strong>signed</strong>: Allows integer types to hold negative values.</li>
        <li><strong>unsigned</strong>: Allows integer types to hold only non-negative values.</li>
    </ul>

    <h3>7. Size of Data Types</h3>
    <p>The size of data types may vary depending on the system architecture (32-bit or 64-bit). You can use the <code>sizeof()</code> operator to determine the size of a data type or a variable in bytes.</p>
    <pre>
std::cout << sizeof(int) << std::endl;  // Output: size of int in bytes
</pre>

</div>

<div class="section" id="cpp-format-specifiers">
    <h2>Format Specifiers in C and C++</h2>
    <p>Format specifiers are used to define the type of data to be input or output in a specific format. In C and C++, format specifiers are used with functions like <code>printf()</code>, <code>scanf()</code>, <code>sprintf()</code>, and others for formatted input and output operations.</p>

    <h3>1. <code>printf()</code> and <code>scanf()</code> Functions</h3>
    <p>The <code>printf()</code> function is used for formatted output, and the <code>scanf()</code> function is used for formatted input. Both of these functions are part of the <code>stdio.h</code> header in C and C++.</p>
    <p>In C++, you can also use <code>std::cout</code> for output and <code>std::cin</code> for input, which are part of the <code>iostream</code> header, but <code>printf()</code> and <code>scanf()</code> are often preferred for specific formatting.</p>

    <h3>2. Common Format Specifiers</h3>
    <h4>2.1 Integer Format Specifiers</h4>
    <p>These specifiers are used to print or scan integer values:</p>
    <ul>
        <li><strong>%d</strong>: Used to print signed integers (int).</li>
        <pre>int num = 10;
printf("The value is %d", num);  // Output: The value is 10</pre>
        <li><strong>%i</strong>: Used to print signed integers (similar to %d).</li>
        <pre>int num = -10;
printf("The value is %i", num);  // Output: The value is -10</pre>
        <li><strong>%u</strong>: Used to print unsigned integers.</li>
        <pre>unsigned int num = 10;
printf("The value is %u", num);  // Output: The value is 10</pre>
        <li><strong>%o</strong>: Used to print integers in octal format.</li>
        <pre>int num = 10;
printf("The octal value is %o", num);  // Output: The octal value is 12</pre>
        <li><strong>%x</strong>: Used to print integers in hexadecimal (lowercase) format.</li>
        <pre>int num = 255;
printf("The hexadecimal value is %x", num);  // Output: The hexadecimal value is ff</pre>
        <li><strong>%X</strong>: Used to print integers in hexadecimal (uppercase) format.</li>
        <pre>int num = 255;
printf("The hexadecimal value is %X", num);  // Output: The hexadecimal value is FF</pre>
        <li><strong>%ld</strong>: Used to print long integers.</li>
        <pre>long num = 123456789;
printf("The long value is %ld", num);  // Output: The long value is 123456789</pre>
    </ul>

    <h4>2.2 Floating-Point Format Specifiers</h4>
    <p>These specifiers are used to print or scan floating-point values:</p>
    <ul>
        <li><strong>%f</strong>: Used to print floating-point numbers (float or double).</li>
        <pre>float num = 3.14;
printf("The value is %f", num);  // Output: The value is 3.140000</pre>
        <li><strong>%lf</strong>: Used to print double precision floating-point numbers. In C++, <code>%f</code> works for both <code>float</code> and <code>double</code>, but it's good practice to use <code>%lf</code> for double.</li>
        <pre>double num = 3.14159265359;
printf("The value is %lf", num);  // Output: The value is 3.141593</pre>
        <li><strong>%e</strong>: Used to print floating-point numbers in scientific notation (lowercase).</li>
        <pre>double num = 12345.6789;
printf("The value is %e", num);  // Output: The value is 1.234568e+04</pre>
        <li><strong>%E</strong>: Used to print floating-point numbers in scientific notation (uppercase).</li>
        <pre>double num = 12345.6789;
printf("The value is %E", num);  // Output: The value is 1.234568E+04</pre>
        <li><strong>%g</strong>: Used to print the floating-point number in either standard or scientific notation, depending on the value.</li>
        <pre>double num = 12345.6789;
printf("The value is %g", num);  // Output: The value is 12345.7</pre>
        <li><strong>%G</strong>: Similar to %g but uses uppercase for scientific notation.</li>
        <pre>double num = 12345.6789;
printf("The value is %G", num);  // Output: The value is 12345.7</pre>
    </ul>

    <h4>2.3 Character Format Specifiers</h4>
    <p>These specifiers are used to print or scan character values:</p>
    <ul>
        <li><strong>%c</strong>: Used to print a single character.</li>
        <pre>char ch = 'A';
printf("The character is %c", ch);  // Output: The character is A</pre>
        <li><strong>%s</strong>: Used to print a string (an array of characters).</li>
        <pre>char str[] = "Hello";
printf("The string is %s", str);  // Output: The string is Hello</pre>
    </ul>

    <h4>2.4 Miscellaneous Format Specifiers</h4>
    <p>These format specifiers have specialized purposes:</p>
    <ul>
        <li><strong>%p</strong>: Used to print a pointer (memory address).</li>
        <pre>int num = 10;
printf("The address of num is %p", &num);  // Output: The address of num is 0x7ffcb38c4d1c</pre>
        <li><strong>%n</strong>: Used to store the number of characters printed so far by <code>printf()</code> in an integer variable.</li>
        <pre>int count;
printf("Hello, world!%n", &count);
printf("The count is %d", count);  // Output: The count is 13</pre>
    </ul>

    <h3>3. <code>scanf()</code> Input Format Specifiers</h3>
    <p>When using <code>scanf()</code>, the format specifiers allow you to capture user input and store it in the appropriate variable.</p>
    <ul>
        <li><strong>%d</strong>: Reads an integer.</li>
        <li><strong>%i</strong>: Reads an integer (same as <code>%d</code>).</li>
        <li><strong>%u</strong>: Reads an unsigned integer.</li>
        <li><strong>%f</strong>: Reads a floating-point number.</li>
        <li><strong>%lf</strong>: Reads a double precision floating-point number.</li>
        <li><strong>%s</strong>: Reads a string (up to the first whitespace).</li>
        <li><strong>%c</strong>: Reads a single character.</li>
        <li><strong>%p</strong>: Reads a pointer.</li>
    </ul>

    <h3>4. Width and Precision</h3>
    <p>Both <code>printf()</code> and <code>scanf()</code> allow specifying the width and precision of the output or input.</p>
    <ul>
        <li><strong>Width</strong>: Specifies the minimum number of characters to be printed. If the value is shorter, it will be padded with spaces (or zeros, if specified).</li>
        <pre>printf("%5d", 10);  // Output: "   10" (padded with spaces to fit width 5)</pre>
        <li><strong>Precision</strong>: Specifies the number of digits to be printed after the decimal point for floating-point numbers.</li>
        <pre>printf("%.2f", 3.14159);  // Output: "3.14"</pre>
    </ul>

    <h3>5. Required Headers</h3>
    <p>To use format specifiers, the following headers are required:</p>
    <ul>
        <li><strong><code>stdio.h</code></strong>: For <code>printf()</code>, <code>scanf()</code>, and other standard I/O functions.</li>
        <li><strong><code>iostream</code></strong>: In C++, you can use <code>std::cout</code> and <code>std::cin</code> for input and output.</li>
    </ul>
</div>

<div class="section" id="cpp-io">
    <h2>Input and Output in C++</h2>
    <p>C++ provides several ways to perform input and output operations, including using the standard input/output stream objects <code>cin</code> and <code>cout</code>. These are part of the <code>iostream</code> library, which allows you to interact with the user through the keyboard and screen.</p>

    <h3>1. Standard Input and Output Streams</h3>
    <p>The most common way to perform input and output in C++ is through the <code>cin</code> and <code>cout</code> streams, which are part of the <code>iostream</code> library.</p>

    <h4>1.1 <code>cin</code> (Standard Input)</h4>
    <p><code>cin</code> is used to read input from the user. The extraction operator <code>>></code> is used to take input from the user and assign it to variables.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int x;
        cout << "Enter an integer: ";
        cin >> x;  // Reads an integer from user input
        cout << "You entered: " << x << endl;
        return 0;
    }
    </pre>
    <p>In the example above, the program prompts the user to enter an integer, reads it into variable <code>x</code>, and then outputs it using <code>cout</code>.</p>

    <h4>1.2 <code>cout</code> (Standard Output)</h4>
    <p><code>cout</code> is used to output data to the standard output (usually the console). The insertion operator <code><<</code> is used to send data to the <code>cout</code> stream.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int x = 10;
        cout << "The value of x is: " << x << endl;
        return 0;
    }
    </pre>
    <p>In this example, <code>cout</code> displays the value of <code>x</code> on the screen with a message.</p>

    <h3>2. Input and Output with Strings</h3>
    <p>C++ also provides easy ways to handle strings as input and output using <code>cin</code> and <code>cout</code>.</p>

    <h4>2.1 <code>cin</code> for Strings</h4>
    <p>For inputting strings, you can use <code>cin</code>. However, when you use <code>cin</code> with strings, it will stop reading input at the first whitespace (space, tab, or newline). To read a full line, you should use <code>getline()</code> instead.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        string name;
        cout << "Enter your name: ";
        cin >> name;  // Reads a single word (up to whitespace)
        cout << "Hello, " << name << "!" << endl;
        return 0;
    }
    </pre>
    <p>If you want to read a full line of text (including spaces), you should use the <code>getline()</code> function:</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        string fullName;
        cout << "Enter your full name: ";
        getline(cin, fullName);  // Reads the entire line, including spaces
        cout << "Hello, " << fullName << "!" << endl;
        return 0;
    }
    </pre>

    <h3>3. Formatting Output</h3>
    <p>C++ allows you to format the output using various manipulators and the <code>iomanip</code> library.</p>

    <h4>3.1 <code>setw()</code></h4>
    <p><code>setw()</code> is used to set the width of the output field.</p>
    <pre>
    #include <iostream>
    #include <iomanip>
    using namespace std;

    int main() {
        int x = 123;
        cout << "Without setw: " << x << endl;
        cout << "With setw(10): " << setw(10) << x << endl;  // Set the output width to 10
        return 0;
    }
    </pre>

    <h4>3.2 <code>setprecision()</code></h4>
    <p><code>setprecision()</code> is used to control the number of decimal places for floating-point output.</p>
    <pre>
    #include <iostream>
    #include <iomanip>
    using namespace std;

    int main() {
        double pi = 3.14159265359;
        cout << "Pi with 3 decimal places: " << setprecision(3) << pi << endl;
        return 0;
    }
    </pre>

    <h4>3.3 <code>fixed</code> and <code>scientific</code></h4>
    <p>These manipulators are used to control the format of floating-point numbers. <code>fixed</code> ensures fixed-point notation, while <code>scientific</code> outputs the number in scientific notation.</p>
    <pre>
    #include <iostream>
    #include <iomanip>
    using namespace std;

    int main() {
        double num = 123456.789;
        cout << "Fixed: " << fixed << setprecision(2) << num << endl;
        cout << "Scientific: " << scientific << setprecision(2) << num << endl;
        return 0;
    }
    </pre>

    <h3>4. File I/O</h3>
    <p>C++ also supports file handling for input and output through file streams. You can use <code>fstream</code> for reading from and writing to files.</p>

    <h4>4.1 Writing to a File</h4>
    <p>To write to a file, you use <code>ofstream</code> (output file stream).</p>
    <pre>
    #include <iostream>
    #include <fstream>
    using namespace std;

    int main() {
        ofstream outFile("example.txt");
        if (outFile.is_open()) {
            outFile << "This is a test file." << endl;
            outFile.close();
        } else {
            cout << "Unable to open file" << endl;
        }
        return 0;
    }
    </pre>

    <h4>4.2 Reading from a File</h4>
    <p>To read from a file, you use <code>ifstream</code> (input file stream).</p>
    <pre>
    #include <iostream>
    #include <fstream>
    using namespace std;

    int main() {
        ifstream inFile("example.txt");
        string line;
        if (inFile.is_open()) {
            while (getline(inFile, line)) {
                cout << line << endl;
            }
            inFile.close();
        } else {
            cout << "Unable to open file" << endl;
        }
        return 0;
    }
    </pre>

    <p>These are the fundamental input and output methods in C++. There are more advanced techniques, but these basic functions will serve as the foundation for most programs you will write.</p>
</div>


        <!-- C++ Operators -->
       <div class="section" id="cpp-operators">
    <h2>Operators in C++</h2>
    <p>In C++, operators are symbols that perform operations on variables and values. Operators are categorized based on their functionality. Below is a list of all the operators in C++, along with their explanations and examples.</p>

    <h3>1. Arithmetic Operators</h3>
    <p>Arithmetic operators are used to perform mathematical calculations.</p>
    <ul>
        <li><code>+</code>: Addition</li>
        <li><code>-</code>: Subtraction</li>
        <li><code>*</code>: Multiplication</li>
        <li><code>/</code>: Division</li>
        <li><code>%</code>: Modulus (remainder)</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 10, b = 5;
        cout << "Addition: " << a + b << endl;
        cout << "Subtraction: " << a - b << endl;
        cout << "Multiplication: " << a * b << endl;
        cout << "Division: " << a / b << endl;
        cout << "Modulus: " << a % b << endl;
        return 0;
    }
    </pre>

    <h3>2. Relational Operators</h3>
    <p>Relational operators are used to compare two values.</p>
    <ul>
        <li><code>==</code>: Equal to</li>
        <li><code>!=</code>: Not equal to</li>
        <li><code>></code>: Greater than</li>
        <li><code><</code>: Less than</li>
        <li><code>>=</code>: Greater than or equal to</li>
        <li><code><=</code>: Less than or equal to</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 10, b = 5;
        cout << "a == b: " << (a == b) << endl;
        cout << "a != b: " << (a != b) << endl;
        cout << "a > b: " << (a > b) << endl;
        cout << "a < b: " << (a < b) << endl;
        cout << "a >= b: " << (a >= b) << endl;
        cout << "a <= b: " << (a <= b) << endl;
        return 0;
    }
    </pre>

    <h3>3. Logical Operators</h3>
    <p>Logical operators are used to perform logical operations, commonly used in control flow and condition checking.</p>
    <ul>
        <li><code>&&</code>: Logical AND</li>
        <li><code>||</code>: Logical OR</li>
        <li><code>!</code>: Logical NOT</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        bool a = true, b = false;
        cout << "a && b: " << (a && b) << endl;
        cout << "a || b: " << (a || b) << endl;
        cout << "!a: " << !a << endl;
        return 0;
    }
    </pre>

    <h3>4. Assignment Operators</h3>
    <p>Assignment operators are used to assign values to variables.</p>
    <ul>
        <li><code>=</code>: Simple assignment</li>
        <li><code>+=</code>: Add and assign</li>
        <li><code>-=</code>: Subtract and assign</li>
        <li><code>*=</code>: Multiply and assign</li>
        <li><code>/=</code>: Divide and assign</li>
        <li><code>%=</code>: Modulus and assign</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 10, b = 5;
        a += b; // a = a + b
        cout << "a += b: " << a << endl;
        a -= b; // a = a - b
        cout << "a -= b: " << a << endl;
        a *= b; // a = a * b
        cout << "a *= b: " << a << endl;
        a /= b; // a = a / b
        cout << "a /= b: " << a << endl;
        a %= b; // a = a % b
        cout << "a %= b: " << a << endl;
        return 0;
    }
    </pre>

    <h3>5. Increment and Decrement Operators</h3>
    <p>These operators are used to increase or decrease the value of a variable by 1.</p>
    <ul>
        <li><code>++</code>: Increment (adds 1)</li>
        <li><code>--</code>: Decrement (subtracts 1)</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 5;
        cout << "a++: " << a++ << endl;  // Post-increment
        cout << "++a: " << ++a << endl;  // Pre-increment
        cout << "a--: " << a-- << endl;  // Post-decrement
        cout << "--a: " << --a << endl;  // Pre-decrement
        return 0;
    }
    </pre>

    <h3>6. Bitwise Operators</h3>
    <p>Bitwise operators perform operations on the binary representation of integers.</p>
    <ul>
        <li><code>&</code>: Bitwise AND</li>
        <li><code>|</code>: Bitwise OR</li>
        <li><code>^</code>: Bitwise XOR</li>
        <li><code>~</code>: Bitwise NOT</li>
        <li><code><<</code>: Left shift</li>
        <li><code>>></code>: Right shift</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 5, b = 3;
        cout << "a & b: " << (a & b) << endl;
        cout << "a | b: " << (a | b) << endl;
        cout << "a ^ b: " << (a ^ b) << endl;
        cout << "~a: " << (~a) << endl;
        cout << "a << 1: " << (a << 1) << endl;
        cout << "a >> 1: " << (a >> 1) << endl;
        return 0;
    }
    </pre>

    <h3>7. Conditional (Ternary) Operator</h3>
    <p>The ternary operator is a shorthand for an <code>if-else</code> statement. It has the following syntax:</p>
    <pre>
    condition ? expression1 : expression2;
    </pre>
    <p>If the condition is true, <code>expression1</code> is evaluated; otherwise, <code>expression2</code> is evaluated.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 5, b = 10;
        cout << (a > b ? "a is greater" : "b is greater") << endl;
        return 0;
    }
    </pre>

    <h3>8. Pointer Operators</h3>
    <p>Pointer operators are used to work with memory addresses and pointer variables.</p>
    <ul>
        <li><code>&</code>: Address-of operator (used to get the address of a variable)</li>
        <li><code>*</code>: Dereference operator (used to access the value at the address stored in a pointer)</li>
    </ul>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 10;
        int* ptr = &a;  // & is the address-of operator
        cout << "Address of a: " << ptr << endl;  // Pointer stores the address
        cout << "Value of a through pointer: " << *ptr << endl;  // Dereferencing the pointer
        return 0;
    }
    </pre>

    <h3>9. Typecast Operator</h3>
    <p>Typecast operator is used to convert one data type to another.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        float a = 9.8;
        int b = (int) a;  // Typecast float to int
        cout << "After typecast: " << b << endl;
        return 0;
    }
    </pre>

    <h3>10. Sizeof Operator</h3>
    <p>The <code>sizeof</code> operator is used to determine the size of a data type or object.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 5;
        cout << "Size of int: " << sizeof(a) << " bytes" << endl;
        return 0;
    }
    </pre>

    <h3>11. Comma Operator</h3>
    <p>The comma operator is used to separate multiple expressions in a single statement, and each expression is evaluated from left to right.</p>
    <pre>
    #include <iostream>
    using namespace std;

    int main() {
        int a = 5, b = 10;
        int c = (a++, b++);
        cout << "After comma operator, a: " << a << ", b: " << b << endl;
        return 0;
    }
    </pre>

    <p>These are all the operators in C++, classified according to their functionality. Understanding operators is crucial for performing various types of operations and controlling program flow.</p>
</div>

        <!-- C++ Control Structures -->
        <div class="section" id="cpp-control-structures">
            <h2>C++ Control Structures</h2>
            <p>Control structures in C++ allow you to make decisions, repeat tasks, and control the flow of execution. Some common control structures are:</p>
            <ul>
                <li><strong>If-Else:</strong> Conditional statements to execute code based on a condition.</li>
                <li><strong>Switch:</strong> Allows multi-way branching based on an expression.</li>
                <li><strong>For Loop:</strong> Used for looping a specific number of times.</li>
                <li><strong>While Loop:</strong> Used for looping while a condition is true.</li>
                <li><strong>Do-While Loop:</strong> Similar to while loop but guarantees at least one iteration.</li>
            </ul>

        </div>


<div class="section" id="cpp-conditional-statements">
    <h2>Conditional Statements in C++</h2>
    <p>Conditional statements allow you to execute a block of code based on certain conditions. In C++, we use <code>if</code>, <code>else</code>, and <code>switch</code> statements for making decisions.</p>

    <h3>1. if Statement</h3>
    <p>The <code>if</code> statement is used to test a condition, and if it evaluates to true, the block of code inside the <code>if</code> statement is executed.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int number = 10;
    if (number > 5) {
        cout &lt;&lt; "Number is greater than 5" &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> <code>Number is greater than 5</code></p>

    <h3>2. if-else Statement</h3>
    <p>The <code>if-else</code> statement allows you to execute one block of code if the condition is true and another block if the condition is false.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int number = 3;
    if (number > 5) {
        cout &lt;&lt; "Number is greater than 5" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Number is less than or equal to 5" &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> <code>Number is less than or equal to 5</code></p>

    <h3>3. if-else if Statement</h3>
    <p>The <code>if-else if</code> statement is used when you have multiple conditions to check, and you want to execute a block of code based on the first condition that evaluates to true.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int number = 15;
    if (number > 20) {
        cout &lt;&lt; "Number is greater than 20" &lt;&lt; endl;
    } else if (number > 10) {
        cout &lt;&lt; "Number is greater than 10 but less than or equal to 20" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Number is less than or equal to 10" &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> <code>Number is greater than 10 but less than or equal to 20</code></p>

    <h3>4. switch Statement</h3>
    <p>The <code>switch</code> statement is used when you have a variable that can take multiple distinct values, and you want to execute different blocks of code based on the value of that variable.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int number = 2;
    switch (number) {
        case 1:
            cout &lt;&lt; "Number is 1" &lt;&lt; endl;
            break;
        case 2:
            cout &lt;&lt; "Number is 2" &lt;&lt; endl;
            break;
        case 3:
            cout &lt;&lt; "Number is 3" &lt;&lt; endl;
            break;
        default:
            cout &lt;&lt; "Number is not 1, 2, or 3" &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> <code>Number is 2</code></p>

    <h3>5. Nested Conditional Statements</h3>
    <p>You can also nest <code>if</code> or <code>switch</code> statements within each other for more complex conditions.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int number = 10;
    if (number > 5) {
        if (number < 15) {
            cout &lt;&lt; "Number is between 5 and 15" &lt;&lt; endl;
        }
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> <code>Number is between 5 and 15</code></p>

    <h3>Summary of Conditional Statements:</h3>
    <ul>
        <li><strong>if:</strong> Executes a block of code if the condition is true.</li>
        <li><strong>else:</strong> Executes a block of code if the condition is false.</li>
        <li><strong>else if:</strong> Used to check multiple conditions.</li>
        <li><strong>switch:</strong> Used to check a variable against multiple cases.</li>
    </ul>

</div>

<div class="section" id="cpp-looping-statements">
    <h2>Looping Statements in C++</h2>
    <p>Loops are used to repeat a block of code as long as a specified condition is true. In C++, we use <code>for</code>, <code>while</code>, and <code>do-while</code> loops to perform repetitive tasks.</p>

    <h3>1. for Loop</h3>
    <p>The <code>for</code> loop is used when the number of iterations is known before entering the loop. It consists of three parts: initialization, condition, and increment/decrement.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i < 5; i++) {
        cout &lt;&lt; "Iteration " &lt;&lt; i+1 &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> 
        <code>Iteration 1</code><br>
        <code>Iteration 2</code><br>
        <code>Iteration 3</code><br>
        <code>Iteration 4</code><br>
        <code>Iteration 5</code>
    </p>

    <h3>2. while Loop</h3>
    <p>The <code>while</code> loop is used when the number of iterations is not known in advance and depends on a condition. The loop runs as long as the condition evaluates to true.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int i = 0;
    while (i < 5) {
        cout &lt;&lt; "Iteration " &lt;&lt; i+1 &lt;&lt; endl;
        i++;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> 
        <code>Iteration 1</code><br>
        <code>Iteration 2</code><br>
        <code>Iteration 3</code><br>
        <code>Iteration 4</code><br>
        <code>Iteration 5</code>
    </p>

    <h3>3. do-while Loop</h3>
    <p>The <code>do-while</code> loop is similar to the <code>while</code> loop, but it guarantees that the loop will run at least once, as the condition is checked after the loop body.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int i = 0;
    do {
        cout &lt;&lt; "Iteration " &lt;&lt; i+1 &lt;&lt; endl;
        i++;
    } while (i < 5);
    return 0;
}
    </pre>
    <p><strong>Output:</strong> 
        <code>Iteration 1</code><br>
        <code>Iteration 2</code><br>
        <code>Iteration 3</code><br>
        <code>Iteration 4</code><br>
        <code>Iteration 5</code>
    </p>

    <h3>4. Nested Loops</h3>
    <p>A loop inside another loop is known as a nested loop. You can use nested loops to perform multi-dimensional iterations, such as printing a pattern.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; ", j=" &lt;&lt; j &lt;&lt; endl;
        }
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong>
        <code>i=0, j=0</code><br>
        <code>i=0, j=1</code><br>
        <code>i=0, j=2</code><br>
        <code>i=1, j=0</code><br>
        <code>i=1, j=1</code><br>
        <code>i=1, j=2</code><br>
        <code>i=2, j=0</code><br>
        <code>i=2, j=1</code><br>
        <code>i=2, j=2</code>
    </p>

    <h3>5. Break and Continue</h3>
    <p>The <code>break</code> statement is used to terminate the loop prematurely, and the <code>continue</code> statement is used to skip the current iteration and move to the next one.</p>
    
    <h4>Example of break:</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i < 5; i++) {
        if (i == 3) {
            break;  // Exit the loop when i is 3
        }
        cout &lt;&lt; "Iteration " &lt;&lt; i+1 &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> 
        <code>Iteration 1</code><br>
        <code>Iteration 2</code><br>
        <code>Iteration 3</code>
    </p>

    <h4>Example of continue:</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            continue;  // Skip the iteration when i is 2
        }
        cout &lt;&lt; "Iteration " &lt;&lt; i+1 &lt;&lt; endl;
    }
    return 0;
}
    </pre>
    <p><strong>Output:</strong> 
        <code>Iteration 1</code><br>
        <code>Iteration 2</code><br>
        <code>Iteration 4</code><br>
        <code>Iteration 5</code>
    </p>

    <h3>Summary of Looping Statements:</h3>
    <ul>
        <li><strong>for:</strong> Used when the number of iterations is known beforehand.</li>
        <li><strong>while:</strong> Used when the number of iterations is not known and depends on a condition.</li>
        <li><strong>do-while:</strong> Similar to <code>while</code>, but guarantees that the loop will run at least once.</li>
        <li><strong>Nested Loops:</strong> A loop inside another loop, useful for multi-dimensional iterations.</li>
        <li><strong>break:</strong> Terminates the loop immediately.</li>
        <li><strong>continue:</strong> Skips the current iteration and moves to the next one.</li>
    </ul>
</div>


<div class="section" id="cpp-arrays">
    <h2>Arrays in C++</h2>
    <p>Arrays in C++ are used to store multiple values in a single variable. Arrays are a collection of elements of the same type stored in contiguous memory locations.</p>

    <h3>1. Single-Dimensional Arrays</h3>
    <p>A single-dimensional array is the simplest form of an array in C++. It stores a collection of similar data types under one name, and each element is accessed using an index.</p>

    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declare and initialize a single-dimensional array
    int arr[5] = {1, 2, 3, 4, 5};

    // Accessing array elements
    cout &lt;&lt; "Element at index 0: " &lt;&lt; arr[0] &lt;&lt; endl;
    cout &lt;&lt; "Element at index 3: " &lt;&lt; arr[3] &lt;&lt; endl;

    // Iterating through the array
    for (int i = 0; i < 5; i++) {
        cout &lt;&lt; "Element at index " &lt;&lt; i &lt;&lt; ": " &lt;&lt; arr[i] &lt;&lt; endl;
    }

    return 0;
}
    </pre>
    <p><strong>Output:</strong>
        <code>Element at index 0: 1</code><br>
        <code>Element at index 3: 4</code><br>
        <code>Element at index 0: 1</code><br>
        <code>Element at index 1: 2</code><br>
        <code>Element at index 2: 3</code><br>
        <code>Element at index 3: 4</code><br>
        <code>Element at index 4: 5</code>
    </p>

    <h3>2. Multi-Dimensional Arrays</h3>
    <p>Multi-dimensional arrays are arrays of arrays. These arrays allow you to store data in two or more dimensions, such as a matrix (2D array). In C++, you can have arrays with any number of dimensions.</p>

    <h4>2.1 Two-Dimensional Arrays</h4>
    <p>A two-dimensional array can be visualized as a table or matrix with rows and columns.</p>

    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declare and initialize a 2D array (3 rows and 3 columns)
    int arr[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    // Accessing elements of a 2D array
    cout &lt;&lt; "Element at [0][0]: " &lt;&lt; arr[0][0] &lt;&lt; endl;
    cout &lt;&lt; "Element at [1][2]: " &lt;&lt; arr[1][2] &lt;&lt; endl;

    // Iterating through the 2D array
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 3; j++) {
            cout &lt;&lt; "Element at [" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "]: " &lt;&lt; arr[i][j] &lt;&lt; endl;
        }
    }

    return 0;
}
    </pre>
    <p><strong>Output:</strong>
        <code>Element at [0][0]: 1</code><br>
        <code>Element at [1][2]: 6</code><br>
        <code>Element at [0][0]: 1</code><br>
        <code>Element at [0][1]: 2</code><br>
        <code>Element at [0][2]: 3</code><br>
        <code>Element at [1][0]: 4</code><br>
        <code>Element at [1][1]: 5</code><br>
        <code>Element at [1][2]: 6</code><br>
        <code>Element at [2][0]: 7</code><br>
        <code>Element at [2][1]: 8</code><br>
        <code>Element at [2][2]: 9</code>
    </p>

    <h4>2.2 Three-Dimensional Arrays</h4>
    <p>A three-dimensional array can be visualized as an array of arrays of arrays. It is often used to represent data in 3D space.</p>

    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declare and initialize a 3D array (2 layers, 3 rows, and 3 columns)
    int arr[2][3][3] = {
        {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
        {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}}
    };

    // Accessing elements of a 3D array
    cout &lt;&lt; "Element at [0][1][2]: " &lt;&lt; arr[0][1][2] &lt;&lt; endl;
    cout &lt;&lt; "Element at [1][2][0]: " &lt;&lt; arr[1][2][0] &lt;&lt; endl;

    // Iterating through the 3D array
    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 3; j++) {
            for (int k = 0; k &lt; 3; k++) {
                cout &lt;&lt; "Element at [" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "][" &lt;&lt; k &lt;&lt; "]: " &lt;&lt; arr[i][j][k] &lt;&lt; endl;
            }
        }
    }

    return 0;
}
    </pre>
    <p><strong>Output:</strong>
        <code>Element at [0][1][2]: 6</code><br>
        <code>Element at [1][2][0]: 16</code><br>
        <code>Element at [0][0][0]: 1</code><br>
        <code>Element at [0][0][1]: 2</code><br>
        <code>Element at [0][0][2]: 3</code><br>
        <code>Element at [0][1][0]: 4</code><br>
        <code>Element at [0][1][1]: 5</code><br>
        <code>Element at [0][1][2]: 6</code><br>
        <code>Element at [0][2][0]: 7</code><br>
        <code>Element at [0][2][1]: 8</code><br>
        <code>Element at [0][2][2]: 9</code><br>
        <code>Element at [1][0][0]: 10</code><br>
        <code>Element at [1][0][1]: 11</code><br>
        <code>Element at [1][0][2]: 12</code><br>
        <code>Element at [1][1][0]: 13</code><br>
        <code>Element at [1][1][1]: 14</code><br>
        <code>Element at [1][1][2]: 15</code><br>
        <code>Element at [1][2][0]: 16</code><br>
        <code>Element at [1][2][1]: 17</code><br>
        <code>Element at [1][2][2]: 18</code>
    </p>

    <h3>3. Array of Strings</h3>
    <p>In C++, an array of strings is simply an array where each element is a string. This allows you to store multiple strings under a single array name.</p>

    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // Declare an array of strings
    string fruits[3] = {"Apple", "Banana", "Cherry"};

    // Accessing array elements
    cout &lt;&lt; "First fruit: " &lt;&lt; fruits[0] &lt;&lt; endl;
    cout &lt;&lt; "Second fruit: " &lt;&lt; fruits[1] &lt;&lt; endl;
    cout &lt;&lt; "Third fruit: " &lt;&lt; fruits[2] &lt;&lt; endl;

    return 0;
}
    </pre>
    <p><strong>Output:</strong>
        <code>First fruit: Apple</code><br>
        <code>Second fruit: Banana</code><br>
        <code>Third fruit: Cherry</code>
    </p>

    <h3>Summary of Array Types:</h3>
    <ul>
        <li><strong>Single-Dimensional Arrays:</strong> Stores a list of similar data types in a single row.</li>
        <li><strong>Multi-Dimensional Arrays:</strong> Arrays of arrays, useful for representing data in multiple dimensions (like matrices).</li>
        <li><strong>Array of Strings:</strong> An array where each element is a string.</li>
    </ul>
</div>


<div class="section" id="cpp-strings">
    <h2>Strings in C++</h2>
    <p>In C++, strings are objects of the <code>std::string</code> class, part of the C++ Standard Library. They provide an easy way to work with sequences of characters. Unlike character arrays in C, strings in C++ are dynamic and handle memory management automatically.</p>

    <h3>Declaring a String</h3>
    <p>A string can be declared using the <code>std::string</code> class or as a character array.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // Declaring a string using std::string class
    string str1 = "Hello, World!";
    
    // Declaring a string using a character array
    char str2[] = "Hello, C++";

    cout &lt;&lt; str1 &lt;&lt; endl;  // Output: Hello, World!
    cout &lt;&lt; str2 &lt;&lt; endl;  // Output: Hello, C++
    
    return 0;
}
    </pre>

    <h3>Common Inbuilt Functions for Strings</h3>
    <p>Here are some of the most commonly used inbuilt functions in C++ to manipulate strings:</p>

    <ul>
        <li><strong>length()</strong> / <strong>size()</strong>: Returns the length (number of characters) in the string.</li>
        <li><strong>empty()</strong>: Checks whether the string is empty (length is 0).</li>
        <li><strong>append()</strong>: Appends a string to the end of another string.</li>
        <li><strong>erase()</strong>: Removes characters from a string starting from a specified position.</li>
        <li><strong>substr()</strong>: Returns a substring of a string.</li>
        <li><strong>find()</strong>: Finds the first occurrence of a substring or character.</li>
        <li><strong>replace()</strong>: Replaces a substring with another string.</li>
        <li><strong>c_str()</strong>: Converts the string into a C-style character array.</li>
        <li><strong>compare()</strong>: Compares two strings lexicographically.</li>
        <li><strong>at()</strong>: Returns the character at a specific position in the string.</li>
    </ul>

    <h3>Example using some of the functions:</h3>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    
    // Length of string
    cout &lt;&lt; "Length of string: " &lt;&lt; str.length() &lt;&lt; endl;  // Output: 13

    // Append
    str.append(" How are you?");
    cout &lt;&lt; "After append: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello, C++! How are you?

    // Substring
    string substr = str.substr(7, 3);
    cout &lt;&lt; "Substring: " &lt;&lt; substr &lt;&lt; endl;  // Output: C++

    // Find
    int index = str.find("C++");
    cout &lt;&lt; "Found 'C++' at index: " &lt;&lt; index &lt;&lt; endl;  // Output: 7

    // Erase
    str.erase(13, 12);
    cout &lt;&lt; "After erase: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello, C++

    // Replace
    str.replace(7, 3, "Java");
    cout &lt;&lt; "After replace: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello, Java!

    return 0;
}
    </pre>

    <h3>Input and Output for Strings</h3>
    <p>Strings can be input and output using the standard <code>cin</code> and <code>cout</code> functions. Here are examples for different ways of taking string input and displaying output:</p>

    <h4>1. Taking Input for Strings</h4>
    <p>Strings can be taken as input either by using <code>cin</code> or <code>getline()</code>. <code>cin</code> is used for simple input, while <code>getline()</code> is used when we want to take input with spaces.</p>

    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // Taking input using cin (stops at the first space)
    string str1;
    cout &lt;&lt; "Enter a string: ";
    cin &gt;&gt; str1;
    cout &lt;&lt; "You entered: " &lt;&lt; str1 &lt;&lt; endl;

    // Taking input using getline (includes spaces)
    string str2;
    cout &lt;&lt; "Enter a sentence: ";
    cin.ignore();  // To clear the input buffer before getline
    getline(cin, str2);
    cout &lt;&lt; "You entered: " &lt;&lt; str2 &lt;&lt; endl;

    return 0;
}
    </pre>

    <p><strong>Output:</strong>
        <code>Enter a string: Hello</code><br>
        <code>You entered: Hello</code><br>
        <code>Enter a sentence: Hello, how are you?</code><br>
        <code>You entered: Hello, how are you?</code>
    </p>

    <h4>2. Displaying Strings using <code>cout</code></h4>
    <p>To display strings, simply use <code>cout</code> followed by the string variable:</p>

    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string greeting = "Welcome to C++ Programming!";
    cout &lt;&lt; greeting &lt;&lt; endl;  // Output: Welcome to C++ Programming!
    return 0;
}
    </pre>

    <h3>Important Notes</h3>
    <ul>
        <li><strong>cin</strong> can be used to input strings but it will stop at the first whitespace (space, tab, newline).</li>
        <li><strong>getline()</strong> is used to input strings that include spaces.</li>
        <li>The <code>c_str()</code> function converts a string into a C-style character array, which can be useful when working with C libraries.</li>
        <li>C++ strings are automatically resized, unlike character arrays in C which need to be predefined with a fixed size.</li>
        <li>Remember to use <code>cin.ignore()</code> before <code>getline()</code> if you're taking multiple inputs with <code>cin</code> and <code>getline()</code> to avoid input buffer issues.</li>
    </ul>
</div>

<div class="section" id="cpp-string-functions">
    <h2>All String Functions in C++ with Examples</h2>
    <p>Here are the inbuilt string functions in C++ with detailed examples to illustrate their use:</p>

    <h3>1. length() or size()</h3>
    <p>The <code>length()</code> or <code>size()</code> function returns the length of the string (the number of characters it contains).</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    cout &lt;&lt; "Length of string: " &lt;&lt; str.length() &lt;&lt; endl;  // Output: 13
    return 0;
}
    </pre>

    <h3>2. empty()</h3>
    <p>The <code>empty()</code> function checks whether the string is empty (i.e., its length is zero).</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "";
    if (str.empty()) {
        cout &lt;&lt; "The string is empty!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "The string is not empty!" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>3. append()</h3>
    <p>The <code>append()</code> function adds a given string to the end of another string.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello";
    str.append(" World");
    cout &lt;&lt; "After append: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello World
    return 0;
}
    </pre>

    <h3>4. erase()</h3>
    <p>The <code>erase()</code> function removes a portion of the string starting from a given position.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    str.erase(5, 2);  // Erases 2 characters starting from index 5
    cout &lt;&lt; "After erase: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello C++!
    return 0;
}
    </pre>

    <h3>5. substr()</h3>
    <p>The <code>substr()</code> function returns a substring from the original string starting from a given position.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    string sub = str.substr(7, 3);  // Extracts the substring starting at index 7, with length 3
    cout &lt;&lt; "Substring: " &lt;&lt; sub &lt;&lt; endl;  // Output: C++
    return 0;
}
    </pre>

    <h3>6. find()</h3>
    <p>The <code>find()</code> function returns the index of the first occurrence of a character or substring within the string. It returns <code>string::npos</code> if the substring is not found.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    int index = str.find("C++");
    if (index != string::npos) {
        cout &lt;&lt; "'C++' found at index: " &lt;&lt; index &lt;&lt; endl;  // Output: 'C++' found at index: 7
    }
    return 0;
}
    </pre>

    <h3>7. replace()</h3>
    <p>The <code>replace()</code> function replaces a part of the string with another string.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    str.replace(7, 3, "Java");  // Replaces the substring starting from index 7 with "Java"
    cout &lt;&lt; "After replace: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello, Java!
    return 0;
}
    </pre>

    <h3>8. c_str()</h3>
    <p>The <code>c_str()</code> function converts the C++ string into a C-style character array (null-terminated).</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello, C++!";
    const char* cstr = str.c_str();
    cout &lt;&lt; "C-style string: " &lt;&lt; cstr &lt;&lt; endl;  // Output: Hello, C++!
    return 0;
}
    </pre>

    <h3>9. compare()</h3>
    <p>The <code>compare()</code> function compares two strings lexicographically.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str1 = "Hello";
    string str2 = "World";
    int result = str1.compare(str2);
    if (result == 0) {
        cout &lt;&lt; "Strings are equal!" &lt;&lt; endl;
    } else if (result < 0) {
        cout &lt;&lt; "str1 is less than str2" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "str1 is greater than str2" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>10. at()</h3>
    <p>The <code>at()</code> function returns the character at a specific index in the string, throwing an exception if the index is out of bounds.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello";
    cout &lt;&lt; "Character at index 1: " &lt;&lt; str.at(1) &lt;&lt; endl;  // Output: e
    return 0;
}
    </pre>

    <h3>11. insert()</h3>
    <p>The <code>insert()</code> function inserts a string into another string at a specified position.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str = "Hello!";
    str.insert(5, " C++");
    cout &lt;&lt; "After insert: " &lt;&lt; str &lt;&lt; endl;  // Output: Hello C++!
    return 0;
}
    </pre>

    <h3>12. swap()</h3>
    <p>The <code>swap()</code> function swaps the contents of two strings.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string str1 = "Hello";
    string str2 = "World";
    str1.swap(str2);
    cout &lt;&lt; "After swap: str1 = " &lt;&lt; str1 &lt;&lt; ", str2 = " &lt;&lt; str2 &lt;&lt; endl;  // Output: str1 = World, str2 = Hello
    return 0;
}
    </pre>

    <h3>Important Notes:</h3>
    <ul>
        <li><strong>cin</strong> is used for string input but it stops at the first whitespace (e.g., space, tab, newline).</li>
        <li><strong>getline()</strong> should be used when you need to input strings that include spaces.</li>
        <li>Functions like <code>find()</code>, <code>substr()</code>, and <code>replace()</code> return substrings and positions of found characters, which makes string manipulation easier.</li>
        <li>The <code>at()</code> function can throw an exception if the index is out of range, so itâ€™s safer than using the index operator <code>[]</code>.</li>
    </ul>
</div>

<div class="section" id="cpp-functions">
    <h2>Functions in C++ with Types and Examples</h2>
    <p>Functions in C++ are used to perform specific tasks and improve code reusability. They are blocks of code that can be called to perform an operation. Functions can be broadly classified into various types based on different criteria.</p>

    <h3>1. Introduction to Functions</h3>
    <p>A function is a group of statements that together perform a task. A function is executed when it is called. It can take parameters, perform a task, and return a result.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void greet() {
    cout &lt;&lt; "Hello, World!" &lt;&lt; endl;  // This is a function with no parameters and no return value
}

int main() {
    greet();  // Calling the greet function
    return 0;
}
    </pre>
    <p>The example above shows a basic function called <code>greet()</code> that prints a message. It does not take any parameters and does not return a value.</p>

    <h3>2. Types of Functions</h3>

    <h4>2.1. Function Without Parameters and Without Return Value</h4>
    <p>This type of function does not take any input and does not return any output.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void display() {
    cout &lt;&lt; "This function does not take parameters nor return a value." &lt;&lt; endl;
}

int main() {
    display();  // Calling the function
    return 0;
}
    </pre>

    <h4>2.2. Function With Parameters But Without Return Value</h4>
    <p>This type of function accepts arguments but does not return any result.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void printSum(int a, int b) {
    cout &lt;&lt; "Sum: " &lt;&lt; (a + b) &lt;&lt; endl;
}

int main() {
    int x = 5, y = 3;
    printSum(x, y);  // Calling the function with parameters
    return 0;
}
    </pre>

    <h4>2.3. Function Without Parameters But With Return Value</h4>
    <p>This type of function does not take input but returns a value.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int getNumber() {
    return 10;
}

int main() {
    int number = getNumber();  // Calling the function and storing the return value
    cout &lt;&lt; "Returned value: " &lt;&lt; number &lt;&lt; endl;
    return 0;
}
    </pre>

    <h4>2.4. Function With Parameters and With Return Value</h4>
    <p>This type of function takes input as parameters and returns a value.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result = multiply(4, 5);  // Calling the function with parameters and storing the return value
    cout &lt;&lt; "Product: " &lt;&lt; result &lt;&lt; endl;
    return 0;
}
    </pre>

    <h3>3. Function Overloading</h3>
    <p>Function overloading is a feature that allows a function to have the same name but different parameters. The correct function is chosen based on the number or type of arguments passed.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int main() {
    cout &lt;&lt; "Sum of integers: " &lt;&lt; add(3, 4) &lt;&lt; endl;  // Calls the int version
    cout &lt;&lt; "Sum of doubles: " &lt;&lt; add(3.5, 4.5) &lt;&lt; endl;  // Calls the double version
    return 0;
}
    </pre>

    <h3>4. Recursion</h3>
    <p>Recursion is a process where a function calls itself to solve a problem. The recursion continues until a base condition is met.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);  // Function calls itself
}

int main() {
    int result = factorial(5);  // Calls the recursive factorial function
    cout &lt;&lt; "Factorial of 5: " &lt;&lt; result &lt;&lt; endl;
    return 0;
}
    </pre>

    <h3>5. Inline Functions</h3>
    <p>Inline functions are those that are expanded in line when called. This is done to reduce the function-call overhead.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

inline int square(int n) {
    return n * n;
}

int main() {
    cout &lt;&lt; "Square of 4: " &lt;&lt; square(4) &lt;&lt; endl;  // Output: 16
    return 0;
}
    </pre>

    <h3>6. Default Arguments</h3>
    <p>Functions in C++ can have default arguments, which are used if no value is provided for them during the function call.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void greet(string name = "Guest") {
    cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!" &lt;&lt; endl;
}

int main() {
    greet();  // Uses default argument "Guest"
    greet("Alice");  // Uses argument "Alice"
    return 0;
}
    </pre>

    <h3>7. Function Pointers</h3>
    <p>Function pointers allow you to store the address of a function and call it indirectly through the pointer.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void sayHello() {
    cout &lt;&lt; "Hello from function pointer!" &lt;&lt; endl;
}

int main() {
    void (*funcPtr)();  // Declaring a function pointer
    funcPtr = &sayHello;  // Storing the address of sayHello function
    funcPtr();  // Calling function through pointer
    return 0;
}
    </pre>

    <h3>8. Lambda Functions</h3>
    <p>Lambda functions in C++ are anonymous functions that can be defined inline.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    auto add = [](int a, int b) { return a + b; };  // Lambda function
    cout &lt;&lt; "Sum: " &lt;&lt; add(5, 3) &lt;&lt; endl;
    return 0;
}
    </pre>

    <h3>9. Types of Functions Based on Return Type</h3>

    <h4>9.1. Functions with Return Type</h4>
    <p>Functions can return values of any data type, such as <code>int</code>, <code>double</code>, or <code>char</code>.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int multiply(int a, int b) {
    return a * b;
}

int main() {
    cout &lt;&lt; "Product: " &lt;&lt; multiply(3, 4) &lt;&lt; endl;  // Returns int
    return 0;
}
    </pre>

    <h4>9.2. Functions with Void Return Type</h4>
    <p>If a function does not return any value, its return type is <code>void</code>.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void printMessage() {
    cout &lt;&lt; "This is a message." &lt;&lt; endl;
}

int main() {
    printMessage();  // No return value
    return 0;
}
    </pre>

    <h3>10. Function Overriding (In Derived Class)</h3>
    <p>Function overriding is a feature in C++ that allows a derived class to provide a specific implementation of a function that is already defined in its base class.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    virtual void show() {  // Virtual function to allow overriding
        cout &lt;&lt; "Base class function" &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    void show() override {  // Overriding the base class function
        cout &lt;&lt; "Derived class function" &lt;&lt; endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;
    basePtr = &derivedObj;
    basePtr-&gt;show();  // Calls derived class function
    return 0;
}
    </pre>

    <p>In this section, we've covered the various types of functions in C++, their usage, and examples. These concepts are essential for writing modular, efficient, and reusable code in C++.</p>
</div>
<div class="section" id="cpp-pointers">
    <h2>Pointers in C++ with Types and Examples</h2>
    <p>A pointer in C++ is a variable that stores the memory address of another variable. It provides a way to indirectly access and manipulate the values stored at different memory locations. Pointers are one of the most powerful and complex features in C++.</p>

    <h3>1. Introduction to Pointers</h3>
    <p>A pointer is defined by specifying the type of variable it points to, followed by an asterisk (*) to indicate that it is a pointer. The pointer stores the memory address of a variable rather than its value.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int a = 5;
    int *ptr = &a;  // Pointer ptr stores the address of variable a
    cout &lt;&lt; "Value of a: " &lt;&lt; a &lt;&lt; endl;         // Direct access to a
    cout &lt;&lt; "Address of a: " &lt;&lt; &a &lt;&lt; endl;      // Address of a
    cout &lt;&lt; "Value stored at ptr: " &lt;&lt; *ptr &lt;&lt; endl;  // Access value using pointer
    cout &lt;&lt; "Address stored in ptr: " &lt;&lt; ptr &lt;&lt; endl;  // Address stored in pointer
    return 0;
}
    </pre>
    <p>In the above example, we declare an integer <code>a</code> and a pointer <code>ptr</code> that stores the address of <code>a</code>. Using <code>*ptr</code> gives the value stored at the address, and <code>ptr</code> gives the address itself.</p>

    <h3>2. Types of Pointers</h3>

    <h4>2.1. Null Pointer</h4>
    <p>A null pointer is a pointer that doesn't point to any valid memory location. It is used to represent an invalid or empty reference.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int *ptr = nullptr;  // Null pointer
    if (ptr == nullptr) {
        cout &lt;&lt; "Pointer is null." &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h4>2.2. Void Pointer</h4>
    <p>A void pointer is a generic pointer that can point to any data type. It has no specific type associated with it and needs to be typecasted before dereferencing.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int a = 5;
    float b = 3.14;
    void *ptr;
    ptr = &a;  // Pointing to integer variable
    cout &lt;&lt; "Value of a: " &lt;&lt; *((int*)ptr) &lt;&lt; endl;  // Typecasting and dereferencing

    ptr = &b;  // Pointing to float variable
    cout &lt;&lt; "Value of b: " &lt;&lt; *((float*)ptr) &lt;&lt; endl;  // Typecasting and dereferencing
    return 0;
}
    </pre>

    <h4>2.3. Pointer to Pointer (Multiple Pointers)</h4>
    <p>A pointer to a pointer is a pointer that stores the address of another pointer. This allows multiple levels of indirection to access the original value.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int a = 10;
    int *ptr = &a;    // Pointer to an integer
    int **ptr2 = &ptr;  // Pointer to pointer

    cout &lt;&lt; "Value of a: " &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; "Value using ptr: " &lt;&lt; *ptr &lt;&lt; endl;  // Dereferencing ptr
    cout &lt;&lt; "Value using ptr2: " &lt;&lt; **ptr2 &lt;&lt; endl;  // Dereferencing ptr2 (double dereference)
    return 0;
}
    </pre>

    <h4>2.4. Function Pointer</h4>
    <p>A function pointer is a pointer that points to the address of a function. It can be used to call functions indirectly.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void displayMessage() {
    cout &lt;&lt; "Hello from function pointer!" &lt;&lt; endl;
}

int main() {
    void (*funcPtr)() = displayMessage;  // Function pointer
    funcPtr();  // Calling function using pointer
    return 0;
}
    </pre>

    <h4>2.5. Array of Pointers</h4>
    <p>An array of pointers is an array where each element is a pointer to a variable of a certain type. This can be used to store addresses of multiple variables of the same type.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int a = 5, b = 10, c = 15;
    int *arr[3];  // Array of pointers
    arr[0] = &a;
    arr[1] = &b;
    arr[2] = &c;

    for (int i = 0; i < 3; i++) {
        cout &lt;&lt; "Value at arr[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; *arr[i] &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h4>2.6. Pointer to Structure</h4>
    <p>A pointer to structure stores the address of a structure variable. It is used to access members of the structure using the pointer.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

struct Person {
    string name;
    int age;
};

int main() {
    Person p1 = {"Alice", 25};
    Person *ptr = &p1;  // Pointer to structure

    cout &lt;&lt; "Name: " &lt;&lt; ptr-&gt;name &lt;&lt; ", Age: " &lt;&lt; ptr-&gt;age &lt;&lt; endl;
    return 0;
}
    </pre>

    <h4>2.7. Pointer to Class (C++ Specific)</h4>
    <p>A pointer to a class is used to access the members of the class, similar to a pointer to a structure. It is used to dynamically allocate objects and access their members through the pointer.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Student {
public:
    string name;
    int age;
    
    void display() {
        cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; endl;
    }
};

int main() {
    Student s = {"John", 20};
    Student *ptr = &s;  // Pointer to class object

    ptr-&gt;display();  // Calling member function using pointer
    return 0;
}
    </pre>

    <h3>3. Pointer Arithmetic</h3>
    <p>Pointer arithmetic refers to the operations performed on pointers, such as incrementing or decrementing a pointer. These operations are based on the size of the data type the pointer is pointing to.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;  // Pointer to array
    
    cout &lt;&lt; "First element: " &lt;&lt; *ptr &lt;&lt; endl;  // Dereferencing first element
    ptr++;  // Pointer arithmetic (move to next element)
    cout &lt;&lt; "Second element: " &lt;&lt; *ptr &lt;&lt; endl;
    
    return 0;
}
    </pre>

    <h3>4. Dynamic Memory Allocation Using Pointers</h3>
    <p>Pointers are used to allocate memory dynamically during runtime using operators <code>new</code> and <code>delete</code>.</p>

    <h4>4.1. Using <code>new</code> to Allocate Memory</h4>
    <p>The <code>new</code> operator is used to allocate memory for a variable or array dynamically from the heap memory.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int *ptr = new int;  // Allocating memory for an integer
    *ptr = 50;
    cout &lt;&lt; "Dynamically allocated value: " &lt;&lt; *ptr &lt;&lt; endl;
    
    delete ptr;  // Deallocating memory
    return 0;
}
    </pre>

    <h4>4.2. Using <code>new</code> for Arrays</h4>
    <p>The <code>new</code> operator can also be used to allocate memory for arrays.</p>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int *arr = new int[3];  // Allocating memory for an array of integers
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    for (int i = 0; i < 3; i++) {
        cout &lt;&lt; "arr[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; arr[i] &lt;&lt; endl;
    }
    
    delete[] arr;  // Deallocating memory for the array
    return 0;
}
    </pre>

    <h3>5. Conclusion</h3>
    <p>Pointers in C++ are essential for efficient memory management, function arguments, and dynamic memory allocation. Understanding pointers, along with their different types, such as pointer-to-pointer and function pointers, is fundamental for mastering C++ programming.</p>
</div>


<div class="section" id="cpp-functions-call-by-value-reference">
    <h2>Function Call by Value and Call by Reference in C++</h2>
    <p>In C++, functions can be called using two primary methods: <b>Call by Value</b> and <b>Call by Reference</b>. These methods differ in how function arguments are passed to the function, affecting the behavior of the program. This section explains both methods with examples.</p>

    <h3>1. Call by Value</h3>
    <p>In <b>Call by Value</b>, a copy of the actual argument is passed to the function. Any changes made to the parameter inside the function do not affect the original argument in the calling function. This is because the function operates on a copy of the data, not the actual data itself.</p>
    
    <h4>1.1. Call by Value Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Function that accepts an argument by value
void addTen(int num) {
    num = num + 10;  // The value of 'num' is modified within the function
    cout &lt;&lt; "Inside addTen function: " &lt;&lt; num &lt;&lt; endl;
}

int main() {
    int x = 5;
    addTen(x);  // Call by value
    cout &lt;&lt; "In main function: " &lt;&lt; x &lt;&lt; endl;  // Original value of 'x' remains unchanged
    return 0;
}
    </pre>
    <p>In this example, the function <code>addTen</code> accepts an integer argument <code>num</code> by value. The value of <code>num</code> is modified within the function, but this change does not affect the original variable <code>x</code> in the <code>main</code> function. The output will be:</p>
    <pre>
Inside addTen function: 15
In main function: 5
    </pre>

    <h3>2. Call by Reference</h3>
    <p>In <b>Call by Reference</b>, the actual memory address of the argument is passed to the function, allowing the function to modify the original variable. The parameter in the function becomes an alias (or reference) to the original argument, meaning any changes made to the parameter will directly affect the argument in the calling function.</p>
    
    <h4>2.1. Call by Reference Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Function that accepts an argument by reference
void addTen(int &num) {
    num = num + 10;  // The value of 'num' is modified within the function
    cout &lt;&lt; "Inside addTen function: " &lt;&lt; num &lt;&lt; endl;
}

int main() {
    int x = 5;
    addTen(x);  // Call by reference
    cout &lt;&lt; "In main function: " &lt;&lt; x &lt;&lt; endl;  // The value of 'x' is changed
    return 0;
}
    </pre>
    <p>In this example, the function <code>addTen</code> accepts an integer argument <code>num</code> by reference (using <code>&</code> in the parameter list). The function modifies the original variable <code>x</code> in the <code>main</code> function. The output will be:</p>
    <pre>
Inside addTen function: 15
In main function: 15
    </pre>

    <h3>3. Differences between Call by Value and Call by Reference</h3>
    <table>
        <tr>
            <th>Feature</th>
            <th>Call by Value</th>
            <th>Call by Reference</th>
        </tr>
        <tr>
            <td>Argument Passing</td>
            <td>A copy of the actual argument is passed to the function.</td>
            <td>The memory address (reference) of the actual argument is passed to the function.</td>
        </tr>
        <tr>
            <td>Effect on Original Variable</td>
            <td>The original variable remains unchanged.</td>
            <td>The original variable is modified.</td>
        </tr>
        <tr>
            <td>Memory Usage</td>
            <td>More memory is used because a copy of the argument is created.</td>
            <td>Less memory is used because no copy of the argument is created.</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Used when the function should not modify the original argument.</td>
            <td>Used when the function needs to modify the original argument.</td>
        </tr>
    </table>

    <h3>4. Conclusion</h3>
    <p>The choice between Call by Value and Call by Reference depends on whether you need to modify the original argument. If you do not want the function to alter the variable, use Call by Value. If you want the function to modify the variable, use Call by Reference. Call by Reference is more efficient when large data structures (such as arrays or objects) need to be passed to functions, as it avoids unnecessary copying of data.</p>
</div>


<div class="section" id="cpp-dynamic-memory-allocation">
    <h2>Dynamic Memory Allocation in C++</h2>
    <p>Dynamic memory allocation in C++ refers to allocating memory during runtime, allowing programs to use memory more flexibly and efficiently. C++ offers two main approaches for dynamic memory allocation: the C-style approach using functions like <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code>, as well as the C++-specific <code>new</code> and <code>delete</code> operators. This section explains both approaches with examples.</p>

    <h3>1. Introduction to Dynamic Memory Allocation</h3>
    <p>In dynamic memory allocation, memory is allocated at runtime from the heap memory area. Unlike static memory allocation, where memory is allocated at compile time, dynamic memory allocation allows for flexible memory usage based on the actual needs of the program. The heap is a region of memory used for such allocations.</p>
    <p>The <code>new</code> and <code>delete</code> operators are C++-specific, while <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code> are C functions used for dynamic memory management.</p>

    <h3>2. C++ Approach: Using the <code>new</code> and <code>delete</code> Operators</h3>
    <p>The <code>new</code> and <code>delete</code> operators are the preferred way of handling dynamic memory allocation and deallocation in C++. They are type-safe and easier to use compared to the C-style functions.</p>

    <h4>2.1. Allocating Memory for Single Variables with <code>new</code></h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int *ptr = new int;  // Allocating memory for a single integer
    *ptr = 10;  // Assigning a value
    cout &lt;&lt; "Value at ptr: " &lt;&lt; *ptr &lt;&lt; endl;

    delete ptr;  // Deleting the allocated memory
    return 0;
}
    </pre>

    <h4>2.2. Allocating Memory for Arrays with <code>new[]</code></h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int *arr = new int[5];  // Allocating memory for an array of 5 integers

    // Assigning values to the array
    for (int i = 0; i < 5; i++) {
        arr[i] = (i + 1) * 10;
    }

    // Displaying values
    for (int i = 0; i < 5; i++) {
        cout &lt;&lt; "arr[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; arr[i] &lt;&lt; endl;
    }

    delete[] arr;  // Deleting the array memory
    return 0;
}
    </pre>

    <h4>2.3. Allocating Memory for Objects with <code>new</code></h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class MyClass {
public:
    int data;
    MyClass(int value) {
        data = value;
    }
};

int main() {
    MyClass *obj = new MyClass(25);  // Dynamically allocating memory for an object
    cout &lt;&lt; "Value of obj->data: " &lt;&lt; obj-&gt;data &lt;&lt; endl;

    delete obj;  // Freeing the object memory
    return 0;
}
    </pre>

    <h3>3. C-Style Dynamic Memory Allocation: <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code></h3>
    <p>C provides a set of functions for dynamic memory allocation, which are available in C++ as well. These functions are part of the C standard library, and they are used to allocate memory blocks from the heap. Unlike <code>new</code> and <code>delete</code>, C functions do not handle memory type safely, and require explicit casting for type handling.</p>

    <h4>3.1. <code>malloc()</code> - Memory Allocation</h4>
    <p>The <code>malloc()</code> function allocates a specified number of bytes of memory and returns a pointer to the beginning of the allocated block. It does not initialize the memory, so it may contain garbage values.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main() {
    int *ptr = (int*)malloc(sizeof(int));  // Allocating memory for a single integer
    if (ptr == NULL) {
        cout &lt;&lt; "Memory allocation failed!" &lt;&lt; endl;
        return -1;
    }

    *ptr = 10;  // Assigning value
    cout &lt;&lt; "Value at ptr: " &lt;&lt; *ptr &lt;&lt; endl;

    free(ptr);  // Deallocating memory
    return 0;
}
    </pre>
    <p>In this example, <code>malloc()</code> is used to allocate memory for a single integer, and <code>free()</code> is used to release the memory.</p>

    <h4>3.2. <code>calloc()</code> - Contiguous Allocation</h4>
    <p>The <code>calloc()</code> function allocates memory for an array of elements and initializes the memory to zero. It is useful when you need to initialize the memory to zero upon allocation.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main() {
    int *arr = (int*)calloc(5, sizeof(int));  // Allocating memory for an array of 5 integers
    if (arr == NULL) {
        cout &lt;&lt; "Memory allocation failed!" &lt;&lt; endl;
        return -1;
    }

    // Displaying values initialized to zero
    for (int i = 0; i < 5; i++) {
        cout &lt;&lt; "arr[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; arr[i] &lt;&lt; endl;
    }

    free(arr);  // Deallocating memory
    return 0;
}
    </pre>
    <p>Here, <code>calloc()</code> allocates memory for an array of 5 integers, initializing each element to zero.</p>

    <h4>3.3. <code>realloc()</code> - Reallocating Memory</h4>
    <p>The <code>realloc()</code> function is used to change the size of an already allocated memory block. It can either increase or decrease the size of the memory, and it may return a new pointer if the memory block is moved to a different location.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main() {
    int *arr = (int*)malloc(3 * sizeof(int));  // Allocating memory for 3 integers
    if (arr == NULL) {
        cout &lt;&lt; "Memory allocation failed!" &lt;&lt; endl;
        return -1;
    }

    // Assigning initial values
    for (int i = 0; i < 3; i++) {
        arr[i] = (i + 1) * 10;
    }

    // Reallocating memory to expand the array
    arr = (int*)realloc(arr, 5 * sizeof(int));  // Expanding the array to hold 5 integers
    if (arr == NULL) {
        cout &lt;&lt; "Memory reallocation failed!" &lt;&lt; endl;
        return -1;
    }

    // Assigning new values
    for (int i = 3; i < 5; i++) {
        arr[i] = (i + 1) * 10;
    }

    // Displaying updated array
    for (int i = 0; i < 5; i++) {
        cout &lt;&lt; "arr[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; arr[i] &lt;&lt; endl;
    }

    free(arr);  // Deallocating memory
    return 0;
}
    </pre>
    <p>Here, <code>realloc()</code> is used to expand the size of an array initially allocated for 3 integers, and the array size is increased to hold 5 integers.</p>

    <h4>3.4. <code>free()</code> - Deallocating Memory</h4>
    <p>The <code>free()</code> function is used to release dynamically allocated memory. It takes a pointer to the memory block that needs to be freed. After calling <code>free()</code>, the memory is returned to the heap, and the pointer should not be used again.</p>

    <h3>4. Summary</h3>
    <p>Dynamic memory allocation allows programs to use memory efficiently at runtime. The C++ approach using <code>new</code> and <code>delete</code> is the preferred method for memory allocation and deallocation. However, C-style functions like <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code> are also available for dynamic memory management. Always ensure to deallocate memory properly to prevent memory leaks.</p>
</div>

<div class="section" id="cpp-structures-unions">
    <h2>Structures and Unions in C++</h2>
    <p>In C++, <b>Structures</b> and <b>Unions</b> are used to group different types of data together. They are similar in many ways but differ in how they store and access their members. This section explains both structures and unions in detail.</p>

    <h3>1. Structures in C++</h3>
    <p>A <b>Structure</b> is a user-defined data type that allows grouping of variables of different data types into a single unit. Each member of a structure can have a different data type.</p>
    
    <h4>1.1. Structure Definition and Declaration</h4>
    <p>Structures are defined using the <code>struct</code> keyword followed by the structure name and its members. The members can be accessed using the dot operator <code>.</code>.</p>

    <h4>1.2. Structure Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Define a structure to store information about a student
struct Student {
    string name;
    int age;
    float grade;
};

int main() {
    // Declare and initialize a structure variable
    Student student1 = {"John", 20, 85.5};

    // Access and print structure members using dot operator
    cout &lt;&lt; "Name: " &lt;&lt; student1.name &lt;&lt; endl;
    cout &lt;&lt; "Age: " &lt;&lt; student1.age &lt;&lt; endl;
    cout &lt;&lt; "Grade: " &lt;&lt; student1.grade &lt;&lt; endl;

    return 0;
}
    </pre>
    <p>In this example, the structure <code>Student</code> is defined with three members: <code>name</code>, <code>age</code>, and <code>grade</code>. A variable <code>student1</code> is declared and initialized with values, and its members are accessed using the dot operator. The output will be:</p>
    <pre>
Name: John
Age: 20
Grade: 85.5
    </pre>

    <h3>2. Unions in C++</h3>
    <p>A <b>Union</b> is a special data type that allows storing different data types in the same memory location. Unlike a structure, a union allocates enough memory to store the largest member, and all members share the same memory space. Only one member can hold a value at any given time, meaning when a new value is assigned to a union member, the previous value is overwritten.</p>

    <h4>2.1. Union Definition and Declaration</h4>
    <p>Unions are defined using the <code>union</code> keyword, and their members are accessed using the dot operator, similar to structures.</p>

    <h4>2.2. Union Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Define a union to store either an integer or a float
union Data {
    int integer;
    float decimal;
};

int main() {
    // Declare and initialize a union variable
    Data data1;
    
    // Assign an integer value to the 'integer' member
    data1.integer = 10;
    cout &lt;&lt; "Integer value: " &lt;&lt; data1.integer &lt;&lt; endl;

    // Assign a float value to the 'decimal' member
    data1.decimal = 20.5;
    cout &lt;&lt; "Float value: " &lt;&lt; data1.decimal &lt;&lt; endl;

    // Accessing the 'integer' member after assigning a float value will give unexpected results
    cout &lt;&lt; "Integer value after assigning float: " &lt;&lt; data1.integer &lt;&lt; endl;

    return 0;
}
    </pre>
    <p>In this example, the union <code>Data</code> can store either an integer or a float, but not both at the same time. Initially, the <code>integer</code> member is assigned a value, but when the <code>decimal</code> member is assigned a value, the integer value is overwritten. The output will be:</p>
    <pre>
Integer value: 10
Float value: 20.5
Integer value after assigning float: 1078523331
    </pre>
    <p>As you can see, the integer value is overwritten by the float value, and accessing it after assigning a new value results in unexpected behavior.</p>

    <h3>3. Key Differences between Structures and Unions</h3>
    <table>
        <tr>
            <th>Feature</th>
            <th>Structure</th>
            <th>Union</th>
        </tr>
        <tr>
            <td>Memory Allocation</td>
            <td>Each member of a structure gets its own memory location.</td>
            <td>All members share the same memory location, and only one member can hold a value at a time.</td>
        </tr>
        <tr>
            <td>Size</td>
            <td>The size of a structure is the sum of the sizes of all its members.</td>
            <td>The size of a union is the size of its largest member.</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Used when different types of data are needed to be stored together, and all members are to be used independently.</td>
            <td>Used when only one member at a time is needed, and memory efficiency is important.</td>
        </tr>
        <tr>
            <td>Memory Efficiency</td>
            <td>Less memory efficient compared to unions.</td>
            <td>More memory efficient compared to structures, as only the largest member is allocated memory.</td>
        </tr>
    </table>

    <h3>4. Conclusion</h3>
    <p>Structures are used when we want to store multiple members (of different types) independently and need to access all members at the same time. Unions are useful when we want to save memory by storing different types of data in the same memory space, but only one data type will be used at any given time. While structures offer more flexibility, unions are more memory-efficient.</p>
</div>

<div class="section" id="memory-allocation-structures-unions">
    <h2>Memory Allocation in Structures and Unions</h2>
    <p>In C++, memory allocation for <b>Structures</b> and <b>Unions</b> is handled differently. The memory layout of structures and unions plays a crucial role in how they store and access their members. This section elaborates on how memory is allocated for both structures and unions, highlighting the differences and the implications of these differences.</p>

    <h3>1. Memory Allocation in Structures</h3>
    <p>When a <b>Structure</b> is declared, memory is allocated for each member individually. This means that the total memory required for a structure is the sum of the sizes of all its members. Each member has its own distinct memory location, and all members are stored independently in memory.</p>
    
    <h4>1.1. Structure Memory Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Define a structure to store student data
struct Student {
    int id;
    char grade;
    float score;
};

int main() {
    // Declare a structure variable
    Student student1;

    // Display the size of the structure
    cout &lt;&lt; "Size of student structure: " &lt;&lt; sizeof(student1) &lt;&lt; " bytes" &lt;&lt; endl;

    return 0;
}
    </pre>
    <p>In the above example, the structure <code>Student</code> consists of three members: an integer <code>id</code>, a character <code>grade</code>, and a float <code>score</code>. The total memory allocated for the <code>Student</code> structure is the sum of the sizes of these members:</p>
    <ul>
        <li>int <code>id</code>: typically 4 bytes</li>
        <li>char <code>grade</code>: typically 1 byte</li>
        <li>float <code>score</code>: typically 4 bytes</li>
    </ul>
    <p>The total size of the structure will be 4 + 1 + 4 = 9 bytes. However, due to memory alignment (which ensures efficient memory access), the size may be padded to a multiple of the largest member's size (in this case, 4 bytes), so the total size could be 12 bytes depending on the system architecture.</p>

    <h3>2. Memory Allocation in Unions</h3>
    <p>Unlike structures, in a <b>Union</b>, all members share the same memory space. The total memory allocated for a union is the size of the largest member. This means that at any given time, only one member can hold a value, and the memory is reused for different types of data. When a new value is assigned to one member, it overwrites the value of the previous member.</p>
    
    <h4>2.1. Union Memory Example</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Define a union to store either an integer or a float
union Data {
    int integer;
    float decimal;
    char character;
};

int main() {
    // Declare a union variable
    Data data1;

    // Display the size of the union
    cout &lt;&lt; "Size of union Data: " &lt;&lt; sizeof(data1) &lt;&lt; " bytes" &lt;&lt; endl;

    return 0;
}
    </pre>
    <p>In the above example, the union <code>Data</code> has three members: an integer <code>integer</code>, a float <code>decimal</code>, and a character <code>character</code>. The total memory allocated for the union is the size of the largest member. Here, the size of the integer (4 bytes) and the size of the float (4 bytes) are the same, and the character is smaller (1 byte). Therefore, the total memory allocated for the union will be 4 bytes, which is the size of the largest member.</p>
    
    <h3>3. Key Differences in Memory Allocation</h3>
    <table>
        <tr>
            <th>Feature</th>
            <th>Structure</th>
            <th>Union</th>
        </tr>
        <tr>
            <td>Memory Allocation</td>
            <td>Each member has its own memory location.</td>
            <td>All members share the same memory location.</td>
        </tr>
        <tr>
            <td>Size</td>
            <td>The size is the sum of the sizes of all the members, with memory padding for alignment.</td>
            <td>The size is the size of the largest member.</td>
        </tr>
        <tr>
            <td>Memory Efficiency</td>
            <td>Less memory efficient, as it allocates memory for each member.</td>
            <td>More memory efficient, as it reuses memory for all members.</td>
        </tr>
        <tr>
            <td>Access to Members</td>
            <td>All members can hold values at the same time and can be accessed independently.</td>
            <td>Only one member can hold a value at a time, and accessing other members may result in undefined behavior.</td>
        </tr>
    </table>

    <h3>4. Conclusion</h3>
    <p>The key difference between structures and unions lies in memory allocation:</p>
    <ul>
        <li>In a <b>Structure</b>, memory is allocated separately for each member, and the total size is the sum of the sizes of all members, considering memory alignment.</li>
        <li>In a <b>Union</b>, memory is allocated for the largest member, and all members share the same memory location. This makes unions more memory efficient, but at the cost of losing the ability to store multiple values simultaneously.</li>
    </ul>
    <p>Therefore, use structures when you need to store multiple values of different types simultaneously and need independent access to them. Use unions when memory efficiency is a concern, and you only need to store one value at a time.</p>
</div>

<div class="section" id="array-of-structures">
    <h2>Array of Structures</h2>
    <p>An <b>Array of Structures</b> is a collection of multiple structure variables stored in a contiguous memory block. Just as you create an array of simple data types (like integers or floats), you can also create an array of structures to store multiple records of the same structure type.</p>

    <h3>1. Syntax of Array of Structures</h3>
    <pre>
struct StructureName {
    dataType member1;
    dataType member2;
    ...
};

StructureName arrayName[size];
    </pre>
    <p>In the above syntax:</p>
    <ul>
        <li><code>StructureName</code> is the name of the structure.</li>
        <li><code>arrayName</code> is the name of the array.</li>
        <li><code>size</code> is the number of elements (structures) in the array.</li>
    </ul>

    <h3>2. Example of Array of Structures</h3>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Define a structure to store information about students
struct Student {
    string name;
    int age;
    float score;
};

int main() {
    // Declare an array of structures
    Student students[3]; // Array of 3 Student structures

    // Taking input for each student
    for(int i = 0; i < 3; i++) {
        cout &lt;&lt; "Enter name of student " &lt;&lt; i+1 &lt;&lt; ": ";
        cin &gt;&gt; students[i].name;
        cout &lt;&lt; "Enter age of student " &lt;&lt; i+1 &lt;&lt; ": ";
        cin &gt;&gt; students[i].age;
        cout &lt;&lt; "Enter score of student " &lt;&lt; i+1 &lt;&lt; ": ";
        cin &gt;&gt; students[i].score;
    }

    // Displaying the information of all students
    cout &lt;&lt; "\nStudent Information:\n";
    for(int i = 0; i < 3; i++) {
        cout &lt;&lt; "Student " &lt;&lt; i+1 &lt;&lt; " - Name: " &lt;&lt; students[i].name 
             &lt;&lt; ", Age: " &lt;&lt; students[i].age 
             &lt;&lt; ", Score: " &lt;&lt; students[i].score &lt;&lt; endl;
    }

    return 0;
}
    </pre>
    <p>In this example, we have an array of 3 <code>Student</code> structures. For each student, we input their <code>name</code>, <code>age</code>, and <code>score</code>. After that, we display the information of all students stored in the array.</p>

    <h3>3. How Memory is Allocated</h3>
    <p>When an array of structures is created, the memory is allocated for each element (structure) separately, but they are stored in contiguous memory locations. Each element of the array contains its own set of members (i.e., each student will have their own <code>name</code>, <code>age</code>, and <code>score</code>).</p>
    
    <h3>4. Accessing Elements of Array of Structures</h3>
    <p>To access individual elements of the array of structures, we use the <code>arrayName[index].memberName</code> syntax, where:</p>
    <ul>
        <li><code>arrayName</code> is the name of the array.</li>
        <li><code>index</code> is the index of the array (starting from 0).</li>
        <li><code>memberName</code> is the name of the member of the structure.</li>
    </ul>
    <p>For example, to access the <code>age</code> of the second student in the array, we would write:</p>
    <pre>
students[1].age; // Accesses the age of the second student
    </pre>

    <h3>5. Advantages of Array of Structures</h3>
    <ul>
        <li>Arrays of structures allow you to store multiple records of the same data type, making it easier to manage and organize large amounts of data.</li>
        <li>They allow direct access to each element and their members, making it efficient for processing and manipulation.</li>
        <li>They provide flexibility in handling complex data types and structures.</li>
    </ul>

    <h3>6. Example with Initialization</h3>
    <pre>
#include &lt;iostream&gt;
using namespace std;

struct Student {
    string name;
    int age;
    float score;
};

int main() {
    // Declare and initialize an array of structures
    Student students[2] = {
        {"John", 20, 85.5},
        {"Jane", 22, 90.2}
    };

    // Display the initialized data
    for(int i = 0; i < 2; i++) {
        cout &lt;&lt; "Student " &lt;&lt; i+1 &lt;&lt; " - Name: " &lt;&lt; students[i].name 
             &lt;&lt; ", Age: " &lt;&lt; students[i].age 
             &lt;&lt; ", Score: " &lt;&lt; students[i].score &lt;&lt; endl;
    }

    return 0;
}
    </pre>
    <p>In this example, we initialize an array of two students with predefined values. This is an efficient way to initialize an array of structures if you already know the values to be stored in the array.</p>

    <h3>7. Conclusion</h3>
    <p>In C++, an <b>Array of Structures</b> allows you to group multiple structure variables into a single array, enabling the storage and management of multiple records efficiently. You can access and manipulate individual elements of the array by using the appropriate index and member names. This is an essential concept when dealing with large datasets or when you need to represent multiple objects with the same properties in a single container.</p>
</div>

<div class="section" id="oops">
    <h2>Object-Oriented Programming (OOP) in C++</h2>
    <p><b>Object-Oriented Programming (OOP)</b> is a programming paradigm that is based on the concept of <b>objects</b>. These objects are instances of user-defined classes, which encapsulate both data (attributes) and methods (functions) that operate on the data.</p>

    <h3>Key Principles of OOP</h3>
    <ul>
        <li><b>Encapsulation:</b> Bundling the data and methods that operate on the data within a single unit (i.e., a class). This restricts direct access to some of the object's components, which can prevent unintended interference and misuse.</li>
        <li><b>Inheritance:</b> Allows a class to inherit properties and behaviors (methods) from another class. This promotes reusability and extension of existing classes.</li>
        <li><b>Polymorphism:</b> The ability to take many forms. It allows methods to do different things based on the object it is acting upon. This is typically achieved through method overloading and overriding.</li>
        <li><b>Abstraction:</b> Hiding the complex implementation details and showing only the necessary features of an object. This helps in simplifying the usage of classes and objects.</li>
    </ul>

    <h3>1. Class and Object</h3>
    <p>A class is a blueprint for creating objects (instances). An object is an instance of a class and can have its own data and functions that are defined in the class.</p>

    <h4>Class Syntax</h4>
    <pre>
class ClassName {
    public:  // Access modifier
        // Data members (variables)
        dataType member1;
        dataType member2;

        // Member functions (methods)
        void function1() {
            // function code
        }
};
    </pre>
    <p>In the above syntax, <code>ClassName</code> is the name of the class, and inside the class, we have data members and member functions. The <code>public</code> keyword specifies that the members are accessible from outside the class.</p>

    <h4>Example: Class and Object</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Car {
public:
    string model;
    int year;

    // Member function
    void display() {
        cout &lt;&lt; "Model: " &lt;&lt; model &lt;&lt; ", Year: " &lt;&lt; year &lt;&lt; endl;
    }
};

int main() {
    // Creating an object of class Car
    Car car1;
    car1.model = "Toyota";
    car1.year = 2020;

    // Calling member function
    car1.display();  // Output: Model: Toyota, Year: 2020

    return 0;
}
    </pre>
    <p>In this example, we define a class <code>Car</code> with two data members: <code>model</code> and <code>year</code>. We create an object <code>car1</code> of the class <code>Car</code>, assign values to the data members, and call the member function <code>display()</code> to show the car details.</p>

    <h3>2. Encapsulation</h3>
    <p>Encapsulation is the process of combining the data (variables) and the functions (methods) into a single unit known as a class. It also involves controlling access to the data using access specifiers:</p>
    <ul>
        <li><code>public</code>: Members are accessible from outside the class.</li>
        <li><code>private</code>: Members are not accessible from outside the class. They can only be accessed by member functions of the same class.</li>
        <li><code>protected</code>: Members are accessible from within the class and its derived classes.</li>
    </ul>

    <h4>Example of Encapsulation</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Employee {
private:
    string name;
    int salary;

public:
    void setData(string n, int s) {
        name = n;
        salary = s;
    }

    void display() {
        cout &lt;&lt; "Employee Name: " &lt;&lt; name &lt;&lt; ", Salary: " &lt;&lt; salary &lt;&lt; endl;
    }
};

int main() {
    Employee emp;
    emp.setData("John Doe", 50000);  // Setting data using setter function
    emp.display();  // Displaying employee data

    return 0;
}
    </pre>
    <p>In this example, the data members <code>name</code> and <code>salary</code> are private, and they cannot be accessed directly from outside the class. Instead, we use the <code>setData()</code> function to set the values and <code>display()</code> to print them.</p>

    <h3>3. Inheritance</h3>
    <p>Inheritance allows one class to inherit the properties and methods from another class. The class that inherits is called the derived class, and the class from which properties are inherited is called the base class.</p>

    <h4>Example of Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Base class
class Vehicle {
public:
    string brand;

    void honk() {
        cout &lt;&lt; "Beep, Beep!" &lt;&lt; endl;
    }
};

// Derived class
class Car : public Vehicle {
public:
    string model;
    int year;

    void display() {
        cout &lt;&lt; "Car Brand: " &lt;&lt; brand &lt;&lt; ", Model: " &lt;&lt; model &lt;&lt; ", Year: " &lt;&lt; year &lt;&lt; endl;
    }
};

int main() {
    Car car1;
    car1.brand = "Toyota";
    car1.model = "Corolla";
    car1.year = 2022;

    car1.honk();  // Calling base class function
    car1.display();  // Calling derived class function

    return 0;
}
    </pre>
    <p>In this example, the <code>Car</code> class is derived from the <code>Vehicle</code> class. The <code>Car</code> class inherits the <code>brand</code> attribute and <code>honk()</code> function from the <code>Vehicle</code> class, and it also adds its own attributes: <code>model</code> and <code>year</code>.</p>

    <h3>4. Polymorphism</h3>
    <p>Polymorphism allows one function or method to perform different tasks based on the object it is called on. In C++, polymorphism is achieved through method overloading and method overriding.</p>

    <h4>Method Overloading</h4>
    <p>Method overloading allows you to define multiple functions with the same name but different parameters. This enables a function to perform different tasks based on the number and types of arguments passed.</p>

    <h4>Example of Method Overloading</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Display {
public:
    void show(int i) {
        cout &lt;&lt; "Integer: " &lt;&lt; i &lt;&lt; endl;
    }

    void show(string str) {
        cout &lt;&lt; "String: " &lt;&lt; str &lt;&lt; endl;
    }
};

int main() {
    Display obj;
    obj.show(10);  // Calling the overloaded function for integer
    obj.show("Hello, World!");  // Calling the overloaded function for string

    return 0;
}
    </pre>
    <p>Here, the <code>show()</code> function is overloaded with two versions: one that accepts an integer and another that accepts a string.</p>

    <h3>5. Abstraction</h3>
    <p>Abstraction is the concept of hiding the implementation details and exposing only the essential features of an object. In C++, this is achieved through abstract classes and pure virtual functions.</p>

    <h4>Example of Abstraction</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Abstract class
class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() {
        cout &lt;&lt; "Drawing a Circle" &lt;&lt; endl;
    }
};

int main() {
    Circle c;
    c.draw();  // Calling the implemented function

    return 0;
}
    </pre>
    <p>In this example, the <code>Shape</code> class is an abstract class because it has a pure virtual function <code>draw()</code>, which is implemented in the derived class <code>Circle</code>.</p>

    <h3>Conclusion</h3>
    <p>OOP in C++ is a powerful paradigm that enhances code reusability, modularity, and maintainability. It makes the development of complex applications more manageable by allowing developers to model real-world entities as objects with attributes and behaviors. By using concepts like encapsulation, inheritance, polymorphism, and abstraction, developers can create more flexible and efficient programs.</p>
</div>


<div class="section" id="inheritance">
    <h2>Inheritance in C++</h2>
    <p><b>Inheritance</b> is a fundamental feature of Object-Oriented Programming (OOP) that allows a class to inherit the properties and behaviors (methods) from another class. The class which inherits the features is called the <b>derived class</b>, and the class from which properties are inherited is called the <b>base class</b>.</p>

    <h3>Types of Inheritance in C++</h3>
    <p>In C++, inheritance can be classified into the following types:</p>
    <ul>
        <li><b>Single Inheritance:</b> When a derived class inherits from a single base class.</li>
        <li><b>Multiple Inheritance:</b> When a derived class inherits from more than one base class.</li>
        <li><b>Multilevel Inheritance:</b> When a class is derived from another derived class, forming a chain of inheritance.</li>
        <li><b>Hierarchical Inheritance:</b> When multiple classes are derived from a single base class.</li>
        <li><b>Hybrid Inheritance:</b> A combination of two or more types of inheritance.</li>
    </ul>

    <h3>1. Single Inheritance</h3>
    <p>In single inheritance, a derived class inherits from one base class. This is the simplest form of inheritance in C++.</p>

    <h4>Example of Single Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    void speak() {
        cout &lt;&lt; "Animal is speaking" &lt;&lt; endl;
    }
};

// Derived class from Animal class
class Dog : public Animal {
public:
    void bark() {
        cout &lt;&lt; "Dog is barking" &lt;&lt; endl;
    }
};

int main() {
    Dog d;
    d.speak();  // Calling base class function
    d.bark();   // Calling derived class function

    return 0;
}
    </pre>
    <p>In this example, the <code>Dog</code> class is derived from the <code>Animal</code> class. The <code>Dog</code> class inherits the <code>speak()</code> method from the <code>Animal</code> class and adds its own <code>bark()</code> method.</p>

    <h3>2. Multiple Inheritance</h3>
    <p>Multiple inheritance occurs when a derived class inherits from more than one base class. This can sometimes lead to ambiguity, especially when the same method or property exists in more than one base class.</p>

    <h4>Example of Multiple Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    void speak() {
        cout &lt;&lt; "Animal is speaking" &lt;&lt; endl;
    }
};

class Bird {
public:
    void fly() {
        cout &lt;&lt; "Bird is flying" &lt;&lt; endl;
    }
};

// Derived class from both Animal and Bird classes
class FlyingAnimal : public Animal, public Bird {
public:
    void sleep() {
        cout &lt;&lt; "Flying animal is sleeping" &lt;&lt; endl;
    }
};

int main() {
    FlyingAnimal fa;
    fa.speak();  // Calling Animal class method
    fa.fly();    // Calling Bird class method
    fa.sleep();  // Calling FlyingAnimal class method

    return 0;
}
    </pre>
    <p>Here, the <code>FlyingAnimal</code> class inherits from both the <code>Animal</code> and <code>Bird</code> classes. It can access the functions from both base classes.</p>

    <h3>3. Multilevel Inheritance</h3>
    <p>In multilevel inheritance, a class is derived from another derived class, forming a chain of inheritance. The derived class can access the properties and methods of its immediate base class, which in turn may have inherited properties from another class.</p>

    <h4>Example of Multilevel Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    void speak() {
        cout &lt;&lt; "Animal is speaking" &lt;&lt; endl;
    }
};

// Derived class from Animal class
class Dog : public Animal {
public:
    void bark() {
        cout &lt;&lt; "Dog is barking" &lt;&lt; endl;
    }
};

// Derived class from Dog class
class Puppy : public Dog {
public:
    void whine() {
        cout &lt;&lt; "Puppy is whining" &lt;&lt; endl;
    }
};

int main() {
    Puppy p;
    p.speak();  // Calling base class function (Animal)
    p.bark();   // Calling derived class function (Dog)
    p.whine();  // Calling derived class function (Puppy)

    return 0;
}
    </pre>
    <p>In this example, the <code>Puppy</code> class inherits from the <code>Dog</code> class, which in turn inherits from the <code>Animal</code> class. The <code>Puppy</code> class has access to all methods from both <code>Dog</code> and <code>Animal</code>.</p>

    <h3>4. Hierarchical Inheritance</h3>
    <p>In hierarchical inheritance, multiple derived classes inherit from a single base class. All the derived classes share the properties and methods of the base class.</p>

    <h4>Example of Hierarchical Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    void speak() {
        cout &lt;&lt; "Animal is speaking" &lt;&lt; endl;
    }
};

// Derived class from Animal class
class Dog : public Animal {
public:
    void bark() {
        cout &lt;&lt; "Dog is barking" &lt;&lt; endl;
    }
};

// Another derived class from Animal class
class Cat : public Animal {
public:
    void meow() {
        cout &lt;&lt; "Cat is meowing" &lt;&lt; endl;
    }
};

int main() {
    Dog d;
    d.speak();  // Calling base class function
    d.bark();   // Calling Dog class function

    Cat c;
    c.speak();  // Calling base class function
    c.meow();   // Calling Cat class function

    return 0;
}
    </pre>
    <p>In this example, both the <code>Dog</code> and <code>Cat</code> classes are derived from the <code>Animal</code> class. They share the <code>speak()</code> method but also have their own unique methods like <code>bark()</code> and <code>meow()</code>.</p>

    <h3>5. Hybrid Inheritance</h3>
    <p>Hybrid inheritance is a combination of two or more types of inheritance. It may involve multiple, multilevel, or hierarchical inheritance combined in one program. Hybrid inheritance can be complex and may lead to ambiguity issues, which is why it is generally not recommended unless necessary.</p>

    <h4>Example of Hybrid Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    void speak() {
        cout &lt;&lt; "Animal is speaking" &lt;&lt; endl;
    }
};

class Bird {
public:
    void fly() {
        cout &lt;&lt; "Bird is flying" &lt;&lt; endl;
    }
};

class FlyingDog : public Animal, public Bird {
public:
    void sleep() {
        cout &lt;&lt; "Flying dog is sleeping" &lt;&lt; endl;
    }
};

int main() {
    FlyingDog fd;
    fd.speak();  // Calling base class function (Animal)
    fd.fly();    // Calling base class function (Bird)
    fd.sleep();  // Calling derived class function (FlyingDog)

    return 0;
}
    </pre>
    <p>In this example, the <code>FlyingDog</code> class inherits from both the <code>Animal</code> and <code>Bird</code> classes, combining two forms of inheritance: multiple inheritance.</p>

    <h3>Access Specifiers in Inheritance</h3>
    <p>In C++, the access level of base class members can be changed in the derived class using access specifiers:</p>
    <ul>
        <li><code>public</code>: Public members of the base class remain public in the derived class.</li>
        <li><code>protected</code>: Public members of the base class become protected in the derived class.</li>
        <li><code>private</code>: Public members of the base class become private in the derived class, meaning they are not accessible from outside the derived class.</li>
    </ul>

    <h4>Example of Access Specifiers in Inheritance</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    int x;
    Base() { x = 10; }
};

class Derived : public Base {
public:
    void display() {
        cout &lt;&lt; "Value of x: " &lt;&lt; x &lt;&lt; endl;  // Accessing public member of Base class
    }
};

int main() {
    Derived d;
    d.display();  // Output: Value of x: 10

    return 0;
}
    </pre>

    <h3>Conclusion</h3>
    <p>Inheritance is a powerful feature of C++ that helps in creating a hierarchical relationship between classes. It enhances code reusability, allows for the creation of more complex systems, and helps to organize code effectively. Understanding and using inheritance properly can greatly improve the efficiency and readability of your programs.</p>
</div>


<div class="section" id="polymorphism">
    <h2>Polymorphism in C++</h2>
    <p><b>Polymorphism</b> is one of the four fundamental principles of Object-Oriented Programming (OOP). It refers to the ability of a function, operator, or object to behave differently based on the context. In simple terms, polymorphism allows one interface to be used for a general class of actions. The specific action depends on the type of object or function being called.</p>

    <h3>Types of Polymorphism</h3>
    <p>Polymorphism can be categorized into two types:</p>
    <ul>
        <li><b>Compile-time Polymorphism (Static Polymorphism):</b> This type of polymorphism is resolved at compile time. It is achieved through <b>function overloading</b> and <b>operator overloading</b>.</li>
        <li><b>Run-time Polymorphism (Dynamic Polymorphism):</b> This type of polymorphism is resolved at runtime. It is achieved through <b>inheritance</b> and <b>virtual functions</b>.</li>
    </ul>

    <h3>1. Compile-time Polymorphism</h3>
    <p>Compile-time polymorphism is resolved by the compiler at the time of compilation. This includes function overloading and operator overloading. It allows multiple functions or operators with the same name but different signatures to exist in the same scope.</p>

    <h4>Function Overloading</h4>
    <p><b>Function Overloading</b> is the ability to define multiple functions with the same name but with different parameters (different number or types of parameters). The compiler distinguishes between the overloaded functions based on the function signature.</p>

    <h5>Example of Function Overloading</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Print {
public:
    void display(int i) {
        cout &lt;&lt; "Integer: " &lt;&lt; i &lt;&lt; endl;
    }
    void display(double d) {
        cout &lt;&lt; "Double: " &lt;&lt; d &lt;&lt; endl;
    }
    void display(string s) {
        cout &lt;&lt; "String: " &lt;&lt; s &lt;&lt; endl;
    }
};

int main() {
    Print p;
    p.display(5);        // Calls display(int)
    p.display(3.14);     // Calls display(double)
    p.display("Hello");  // Calls display(string)

    return 0;
}
    </pre>
    <p>In this example, the <code>display</code> function is overloaded three times with different parameter types: <code>int</code>, <code>double</code>, and <code>string</code>.</p>

    <h4>Operator Overloading</h4>
    <p><b>Operator Overloading</b> allows you to define the behavior of operators (like +, -, *, etc.) for user-defined data types. You can change how operators work for objects of your own classes.</p>

    <h5>Example of Operator Overloading</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Complex {
public:
    int real, imag;

    Complex(int r, int i) : real(r), imag(i) {}

    // Overloading + operator
    Complex operator + (Complex const &other) {
        return Complex(real + other.real, imag + other.imag);
    }

    void display() {
        cout &lt;&lt; "Real: " &lt;&lt; real &lt;&lt; ", Imaginary: " &lt;&lt; imag &lt;&lt; endl;
    }
};

int main() {
    Complex c1(3, 4), c2(1, 2);
    Complex c3 = c1 + c2;  // Calls overloaded operator +
    c3.display();  // Output: Real: 4, Imaginary: 6

    return 0;
}
    </pre>
    <p>Here, we have overloaded the <code>+</code> operator to add two <code>Complex</code> objects. The result of <code>c1 + c2</code> is stored in <code>c3</code>.</p>

    <h3>2. Run-time Polymorphism</h3>
    <p>Run-time polymorphism occurs when the method to be invoked is determined at runtime. This type of polymorphism is achieved through inheritance and virtual functions. The base class contains a virtual function, and the derived class overrides this function. The function call is resolved at runtime based on the object type.</p>

    <h4>Virtual Functions</h4>
    <p>A <b>virtual function</b> is a function that is declared in the base class and is overridden in the derived class. The <code>virtual</code> keyword ensures that the correct function is called for an object, regardless of the type of reference (base class or derived class) used for the call.</p>

    <h5>Example of Run-time Polymorphism using Virtual Functions</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Animal {
public:
    virtual void sound() {
        cout &lt;&lt; "Animal makes a sound" &lt;&lt; endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {
        cout &lt;&lt; "Dog barks" &lt;&lt; endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout &lt;&lt; "Cat meows" &lt;&lt; endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();
    
    animal1->sound();  // Output: Dog barks
    animal2->sound();  // Output: Cat meows

    delete animal1;
    delete animal2;

    return 0;
}
    </pre>
    <p>In this example, the <code>sound</code> method is declared as virtual in the base class <code>Animal</code>. The derived classes <code>Dog</code> and <code>Cat</code> override the method. At runtime, the correct method is called based on the object type, even though the base class pointer is used.</p>

    <h3>Pure Virtual Functions and Abstract Classes</h3>
    <p>A <b>pure virtual function</b> is a function that has no implementation in the base class and must be implemented in the derived class. If a class contains any pure virtual functions, it becomes an <b>abstract class</b>, meaning you cannot create objects of that class directly.</p>

    <h5>Example of Abstract Class with Pure Virtual Function</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override {
        cout &lt;&lt; "Drawing Circle" &lt;&lt; endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout &lt;&lt; "Drawing Rectangle" &lt;&lt; endl;
    }
};

int main() {
    Shape* shape1 = new Circle();
    Shape* shape2 = new Rectangle();
    
    shape1->draw();  // Output: Drawing Circle
    shape2->draw();  // Output: Drawing Rectangle

    delete shape1;
    delete shape2;

    return 0;
}
    </pre>
    <p>In this example, <code>Shape</code> is an abstract class because it has a pure virtual function <code>draw()</code>. The derived classes <code>Circle</code> and <code>Rectangle</code> implement this function, allowing us to create objects of those classes.</p>

    <h3>Advantages of Polymorphism</h3>
    <ul>
        <li><b>Code Reusability:</b> Polymorphism promotes code reuse and can lead to cleaner and more maintainable code.</li>
        <li><b>Flexibility:</b> It provides flexibility by allowing a single function to be used with different types of objects, thus reducing the need for multiple functions or code duplication.</li>
        <li><b>Extensibility:</b> New derived classes can be added without modifying the existing code, which makes extending a program easier.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Polymorphism is a powerful feature in C++ that enhances the flexibility and maintainability of code. By allowing functions to behave differently based on the object they are invoked on, polymorphism helps in creating more dynamic and modular programs. Whether it's through function overloading, operator overloading, or run-time polymorphism with virtual functions, polymorphism is a core concept that every C++ programmer should master.</p>
</div>

<div class="section" id="polymorphism">
    <h2>Polymorphism in C++</h2>
    <p><b>Polymorphism</b> is one of the core concepts of Object-Oriented Programming (OOP) that allows one interface to be used for different types of objects. The word "Polymorphism" comes from Greek, meaning "many forms." In C++, polymorphism allows methods to do different things based on the object it is acting upon.</p>

    <h3>What is Polymorphism?</h3>
    <p>Polymorphism enables a single function, method, or operator to work in different ways depending on the object type or the parameters passed. Essentially, polymorphism allows you to write code that works with objects of different classes as though they are of the same type, and the behavior is determined at runtime.</p>

    <h3>Types of Polymorphism</h3>
    <p>In C++, there are two main types of polymorphism:</p>
    <ul>
        <li><b>Compile-time Polymorphism</b> (also known as Static Polymorphism)</li>
        <li><b>Runtime Polymorphism</b> (also known as Dynamic Polymorphism)</li>
    </ul>

    <h3>1. Compile-time Polymorphism (Static Polymorphism)</h3>
    <p>Compile-time polymorphism is resolved during the compilation of the program. It is achieved through function overloading and operator overloading in C++.</p>

    <h4>Function Overloading</h4>
    <p>Function overloading allows you to define multiple functions with the same name, but with different parameter types or numbers. The function that gets called is determined at compile time based on the arguments passed during the function call.</p>

    <h5>Example: Function Overloading</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Calculator {
public:
    // Function to add two integers
    int add(int a, int b) {
        return a + b;
    }

    // Overloaded function to add three integers
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded function to add two floats
    float add(float a, float b) {
        return a + b;
    }
};

int main() {
    Calculator calc;
    cout &lt;&lt; "Sum of 2 integers: " &lt;&lt; calc.add(5, 10) &lt;&lt; endl;   // Calls add(int, int)
    cout &lt;&lt; "Sum of 3 integers: " &lt;&lt; calc.add(5, 10, 15) &lt;&lt; endl; // Calls add(int, int, int)
    cout &lt;&lt; "Sum of 2 floats: " &lt;&lt; calc.add(5.5f, 10.2f) &lt;&lt; endl; // Calls add(float, float)
    return 0;
}
    </pre>
    <p>In this example, we have overloaded the <code>add</code> function in the <code>Calculator</code> class to handle different numbers and types of parameters. The function call is resolved at compile time based on the type and number of arguments.</p>

    <h4>Operator Overloading</h4>
    <p>Operator overloading allows you to define how operators like <code>+</code>, <code>-</code>, <code>*</code>, etc., behave for objects of user-defined classes. This is a form of compile-time polymorphism because the compiler determines which operator version to use at compile time based on the operands.</p>

    <h5>Example: Operator Overloading</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Complex {
public:
    int real, imag;

    Complex operator + (Complex const &other) {
        Complex temp;
        temp.real = real + other.real;
        temp.imag = imag + other.imag;
        return temp;
    }
};

int main() {
    Complex c1, c2, c3;
    c1.real = 5; c1.imag = 6;
    c2.real = 10; c2.imag = 12;
    
    c3 = c1 + c2;  // Uses overloaded + operator
    
    cout &lt;&lt; "Result: " &lt;&lt; c3.real &lt;&lt; " + " &lt;&lt; c3.imag &lt;&lt; "i" &lt;&lt; endl;
    return 0;
}
    </pre>
    <p>In the above example, we have overloaded the <code>+</code> operator for the <code>Complex</code> class. This allows us to add two <code>Complex</code> objects using the <code>+</code> operator, and the compiler determines the correct operation during compilation.</p>

    <h3>2. Runtime Polymorphism (Dynamic Polymorphism)</h3>
    <p>Runtime polymorphism is achieved through inheritance and virtual functions. The decision of which method to call is made at runtime based on the object type, not the reference type. This is typically implemented using <code>virtual</code> functions and pointers or references to base classes.</p>

    <h4>Virtual Functions</h4>
    <p>A virtual function is a function that is declared in the base class and overridden in the derived class. When using a pointer or reference to the base class, the correct function is called based on the actual object type at runtime, not the type of the pointer or reference.</p>

    <h5>Example: Runtime Polymorphism with Virtual Functions</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    virtual void display() {
        cout &lt;&lt; "Display function in Base class" &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        cout &lt;&lt; "Display function in Derived class" &lt;&lt; endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;

    // basePtr points to derived object, runtime polymorphism occurs
    basePtr = &derivedObj;
    basePtr-&gt;display();  // Calls display() in Derived class, not Base class

    return 0;
}
    </pre>
    <p>In the above example, even though <code>basePtr</code> is a pointer to the base class, it calls the <code>display()</code> method from the derived class at runtime. This is because <code>display()</code> is a virtual function, and the actual object type determines which function is called.</p>

    <h3>Advantages of Polymorphism</h3>
    <ul>
        <li><b>Code Reusability:</b> Polymorphism allows you to reuse code by working with different types of objects through a common interface.</li>
        <li><b>Extensibility:</b> It makes your code more flexible and extensible, as new derived classes can be introduced without changing existing code.</li>
        <li><b>Maintainability:</b> Polymorphism simplifies code maintenance by reducing the need to rewrite functions or methods for different object types.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Polymorphism is a powerful feature of OOP that enhances code flexibility, reusability, and extensibility. By allowing the same function or operator to behave differently depending on the object type, polymorphism simplifies code maintenance and increases scalability in larger systems. In C++, polymorphism is mainly achieved through function overloading, operator overloading, and virtual functions.</p>
</div>

<div class="section" id="encapsulation">
    <h2>Encapsulation in C++</h2>
    <p><b>Encapsulation</b> is one of the fundamental principles of Object-Oriented Programming (OOP). It is the mechanism of bundling the data (variables) and the methods (functions) that operate on the data into a single unit, often called a <b>class</b>. It restricts direct access to some of an object's components, which helps in preventing accidental modification of data and enforcing proper data access through well-defined interfaces.</p>

    <h3>What is Encapsulation?</h3>
    <p>In simpler terms, encapsulation refers to the concept of keeping the data safe from outside interference and misuse. This is achieved by:</p>
    <ul>
        <li>Declaring data as private (or protected) so that it cannot be accessed directly from outside the class.</li>
        <li>Providing public methods (getters and setters) to access and modify the private data in a controlled manner.</li>
    </ul>

    <h3>Why is Encapsulation Important?</h3>
    <p>Encapsulation is important because it helps in:</p>
    <ul>
        <li><b>Data Hiding:</b> It hides the internal workings of an object and only exposes the necessary parts of it. This prevents unauthorized access and modification of data.</li>
        <li><b>Code Reusability:</b> Encapsulation helps in creating classes that can be reused in different parts of the program without exposing the internal data and operations.</li>
        <li><b>Flexibility and Maintainability:</b> Since internal implementations can be modified without affecting other parts of the program, encapsulation enhances flexibility and maintainability.</li>
        <li><b>Control over Data:</b> With encapsulation, we can control how the data is modified and validated, ensuring that invalid data is not set.</li>
    </ul>

    <h3>Example of Encapsulation</h3>
    <p>Letâ€™s consider a class <code>Account</code> that encapsulates the data related to a bank account (balance) and provides methods to safely access and modify the balance.</p>

    <h5>Example of Encapsulation in Action</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Account {
private:
    double balance;  // Private data member

public:
    // Constructor to initialize balance
    Account(double initial_balance) {
        if (initial_balance > 0) {
            balance = initial_balance;
        } else {
            balance = 0;
        }
    }

    // Getter method to access the balance
    double getBalance() {
        return balance;
    }

    // Setter method to deposit money into the account
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        } else {
            cout &lt;&lt; "Deposit amount must be positive!" &lt;&lt; endl;
        }
    }

    // Setter method to withdraw money from the account
    void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        } else {
            cout &lt;&lt; "Invalid withdrawal amount!" &lt;&lt; endl;
        }
    }
};

int main() {
    Account acc1(1000);  // Creating an Account object with an initial balance of 1000
    cout &lt;&lt; "Initial Balance: " &lt;&lt; acc1.getBalance() &lt;&lt; endl;

    acc1.deposit(500);  // Depositing money
    cout &lt;&lt; "Balance after deposit: " &lt;&lt; acc1.getBalance() &lt;&lt; endl;

    acc1.withdraw(200);  // Withdrawing money
    cout &lt;&lt; "Balance after withdrawal: " &lt;&lt; acc1.getBalance() &lt;&lt; endl;

    acc1.withdraw(2000);  // Invalid withdrawal
    cout &lt;&lt; "Balance after invalid withdrawal: " &lt;&lt; acc1.getBalance() &lt;&lt; endl;

    return 0;
}
    </pre>
    <p>In this example, the <code>balance</code> is a private data member, which cannot be directly accessed from outside the class. The methods <code>getBalance()</code>, <code>deposit()</code>, and <code>withdraw()</code> provide controlled access to the balance. For example, the <code>deposit()</code> method ensures that only positive amounts are added to the balance, and the <code>withdraw()</code> method checks whether the withdrawal amount is valid.</p>

    <h3>Encapsulation: Access Modifiers</h3>
    <p>In C++, encapsulation is implemented using access modifiers. These modifiers specify the accessibility of the class members. There are three main types of access modifiers in C++:</p>
    <ul>
        <li><b>Private:</b> Members declared as private can only be accessed within the class and not from outside the class. It is used to hide data that should not be accessed directly.</li>
        <li><b>Public:</b> Members declared as public can be accessed from anywhere, both inside and outside the class. Public methods are used to provide controlled access to private members.</li>
        <li><b>Protected:</b> Members declared as protected are accessible within the class and by derived classes, but not by other objects. It is a more restrictive form of public access.</li>
    </ul>

    <h5>Example of Access Modifiers</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Person {
private:
    string name;  // Private member

public:
    int age;  // Public member

    // Constructor to initialize name and age
    Person(string person_name, int person_age) {
        name = person_name;
        age = person_age;
    }

    // Public method to access private member
    string getName() {
        return name;
    }
};

int main() {
    Person p("John Doe", 30);
    cout &lt;&lt; "Name: " &lt;&lt; p.getName() &lt;&lt; endl;  // Accessing private member using getter
    cout &lt;&lt; "Age: " &lt;&lt; p.age &lt;&lt; endl;  // Accessing public member directly

    return 0;
}
    </pre>
    <p>In this example, the <code>name</code> member is private, so it cannot be accessed directly from outside the class. However, the <code>age</code> member is public and can be accessed directly. To access the private <code>name</code>, we use the public method <code>getName()</code>.</p>

    <h3>Encapsulation in C++ vs Other Programming Languages</h3>
    <p>Encapsulation is a concept that is common to all Object-Oriented Programming (OOP) languages, but its implementation and rules can vary slightly depending on the language. For example, C++ provides the ability to use access modifiers to hide data and give controlled access via getter and setter methods. Other languages like Java and Python also support encapsulation, though Python does not strictly enforce private members and uses naming conventions like prefixing with an underscore (<code>_</code>) to indicate private members.</p>

    <h3>Advantages of Encapsulation</h3>
    <ul>
        <li><b>Data Security:</b> Encapsulation helps secure data by restricting direct access to it. Only authorized methods can modify or retrieve the data, ensuring that it remains consistent and valid.</li>
        <li><b>Reduced Complexity:</b> It reduces the complexity of a program by hiding unnecessary implementation details from the user, providing only essential functionality.</li>
        <li><b>Improved Maintainability:</b> Since the internal implementation can be modified without affecting the external interface, encapsulation improves the maintainability and flexibility of the code.</li>
        <li><b>Better Code Organization:</b> Encapsulation helps organize code into logical units (classes) with clearly defined responsibilities, making the code more modular and easier to understand.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Encapsulation is a core concept of Object-Oriented Programming in C++. It allows you to bundle the data and the methods that operate on the data into a single unit (class), restricting direct access to the data. By providing controlled access through public methods, encapsulation helps in ensuring the integrity of the data and improves the maintainability, flexibility, and security of your code. In addition, the use of access modifiers (private, public, and protected) further enhances the control over how data is accessed and modified.</p>
</div>


<div class="section" id="data-abstraction">
    <h2>Data Abstraction in C++</h2>
    <p><b>Data Abstraction</b> is one of the key concepts of Object-Oriented Programming (OOP). It refers to the concept of hiding the complex implementation details of an object and exposing only the necessary and relevant features to the user. In other words, data abstraction allows you to define the <b>what</b> an object does, without specifying <b>how</b> it does it.</p>

    <h3>What is Data Abstraction?</h3>
    <p>Data abstraction enables the programmer to focus on the essential features of an object without being concerned about its internal workings. It hides the internal complexity of an object by providing a simplified interface through which interaction with the object can take place. This is achieved by using abstract classes and interfaces in C++.</p>
    <p>While encapsulation focuses on bundling data and methods together, abstraction focuses on exposing only the essential parts of an object and hiding unnecessary details. This makes the code easier to manage, understand, and modify.</p>

    <h3>Why is Data Abstraction Important?</h3>
    <p>Data abstraction is important for the following reasons:</p>
    <ul>
        <li><b>Reduces Complexity:</b> By hiding the internal details, abstraction simplifies the interaction with complex systems. It only exposes the necessary functionality to the user.</li>
        <li><b>Enhances Flexibility:</b> Since implementation details are hidden, changes to the internal workings of an object can be made without affecting the rest of the system.</li>
        <li><b>Improves Code Maintenance:</b> Abstraction allows for better management of code by separating the interface (what the object does) from its implementation (how it does it).</li>
        <li><b>Supports Reusability:</b> By using abstract interfaces, code can be reused across different parts of the system without needing to know the internal workings of the objects.</li>
    </ul>

    <h3>Data Abstraction in C++</h3>
    <p>In C++, data abstraction is primarily achieved using <b>abstract classes</b> and <b>pure virtual functions</b>. An abstract class is a class that contains at least one pure virtual function. A pure virtual function is a function that is declared in a base class, but does not have any implementation in that class. It must be implemented by any derived class. An abstract class cannot be instantiated directly.</p>

    <h3>Abstract Classes and Pure Virtual Functions</h3>
    <p>An abstract class is a class that serves as a base for other classes. It may contain abstract methods that need to be implemented by derived classes. These abstract methods are called <b>pure virtual functions</b>. A pure virtual function is declared by appending <code>= 0</code> to the function declaration.</p>

    <h5>Example of Data Abstraction using Abstract Classes</h5>
    <pre>
#include &lt;iostream&gt;
using namespace std;

// Abstract class
class Shape {
public:
    // Pure virtual function (abstract function)
    virtual void draw() = 0;  // No implementation in base class

    // Other non-abstract functions can exist in the base class
    void description() {
        cout &lt;&lt; "This is a shape." &lt;&lt; endl;
    }
};

// Derived class from Shape
class Circle : public Shape {
public:
    // Providing implementation for the pure virtual function
    void draw() override {
        cout &lt;&lt; "Drawing a Circle." &lt;&lt; endl;
    }
};

// Derived class from Shape
class Square : public Shape {
public:
    // Providing implementation for the pure virtual function
    void draw() override {
        cout &lt;&lt; "Drawing a Square." &lt;&lt; endl;
    }
};

int main() {
    // Shape s;  // Error: cannot instantiate an abstract class
    Shape* shape1 = new Circle();
    Shape* shape2 = new Square();

    shape1-&gt;draw();  // Drawing a Circle.
    shape2-&gt;draw();  // Drawing a Square.

    delete shape1;
    delete shape2;

    return 0;
}
    </pre>
    <p>In the above example, the class <code>Shape</code> is an abstract class because it has the pure virtual function <code>draw()</code>. The derived classes <code>Circle</code> and <code>Square</code> provide implementations for the <code>draw()</code> function. You cannot create an object of the abstract class <code>Shape</code> directly, but you can use it as a pointer or reference to call the functions of the derived classes.</p>

    <h3>Abstract Classes in C++ vs Other Languages</h3>
    <p>Data abstraction in C++ works similarly to other Object-Oriented Programming languages like Java or Python. However, there are a few key differences:</p>
    <ul>
        <li><b>C++:</b> In C++, abstract classes are created using pure virtual functions, and classes that implement them must provide definitions for the pure virtual functions.</li>
        <li><b>Java:</b> Java uses abstract classes and interfaces to achieve abstraction. Java supports both abstract methods and interfaces to abstract away the details of class implementation.</li>
        <li><b>Python:</b> Python does not have a strict implementation of abstract classes, but it allows abstraction using abstract base classes (ABCs) from the <code>abc</code> module. It supports abstract methods that must be implemented in the subclasses.</li>
    </ul>

    <h3>Abstraction in Practice</h3>
    <p>In real-world programming, data abstraction is often used to manage complex systems. For example, a <code>Database</code> class might provide an abstract interface to interact with various types of databases (e.g., MySQL, PostgreSQL), without revealing the specific connection details, query execution, or error handling to the end user. The user only interacts with methods like <code>connect()</code>, <code>disconnect()</code>, and <code>query()</code>, while the underlying database-specific details are hidden.</p>

    <h3>Advantages of Data Abstraction</h3>
    <ul>
        <li><b>Improved Security:</b> Data abstraction hides internal implementation details, making the system more secure by preventing unauthorized access.</li>
        <li><b>Simplification:</b> It allows the programmer to focus on the essential features of the object without worrying about the complex internal logic.</li>
        <li><b>Ease of Maintenance:</b> Since the internal details are hidden, changes in the implementation do not affect the user of the class, making it easier to maintain the code.</li>
        <li><b>Code Reusability:</b> By defining abstract interfaces, the same interface can be used across different types of objects or classes, increasing the reusability of the code.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Data abstraction is an important principle of Object-Oriented Programming that allows developers to design software by focusing on what an object does, rather than how it does it. In C++, this is achieved using abstract classes and pure virtual functions. Data abstraction simplifies code, increases security, promotes code reusability, and enhances maintainability. By hiding unnecessary implementation details, abstraction helps in building more flexible and scalable software systems.</p>
</div>

<div class="section" id="virtual-functions-and-destructors">
    <h2>Virtual Functions and Virtual Destructors</h2>
    
    <h3>1. Virtual Functions</h3>
    <p>A <b>virtual function</b> is a member function in the base class that is redefined (overridden) in the derived class. It is used to achieve <b>runtime polymorphism</b>. When a function is declared as virtual in the base class, the function to be invoked is determined at runtime based on the actual object type, not the type of the pointer or reference.</p>

    <h4>Why use Virtual Functions?</h4>
    <p>Virtual functions allow for dynamic (runtime) polymorphism in C++. The function call is resolved dynamically, meaning the function that gets executed depends on the object type that the base class pointer or reference is pointing to at runtime. This allows for more flexible and reusable code.</p>

    <h4>Example: Virtual Functions</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    // Virtual function
    virtual void display() {
        cout &lt;&lt; "Display function in Base class" &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    // Overriding the virtual function
    void display() override {
        cout &lt;&lt; "Display function in Derived class" &lt;&lt; endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;

    // basePtr points to derived object, runtime polymorphism occurs
    basePtr = &derivedObj;
    basePtr-&gt;display();  // Calls display() in Derived class, not Base class

    return 0;
}
    </pre>
    <p>In the example above, we declare the <code>display()</code> function as a virtual function in the <code>Base</code> class. When we call the function using a base class pointer (<code>basePtr</code>) pointing to an object of the derived class (<code>derivedObj</code>), the function in the derived class is called, not the one in the base class. This is known as runtime polymorphism.</p>

    <h4>Important Notes about Virtual Functions:</h4>
    <ul>
        <li>A function must be declared as <code>virtual</code> in the base class to enable dynamic dispatch.</li>
        <li>If a derived class doesn't override a virtual function, the base class version is invoked.</li>
        <li>Virtual functions can be overridden in derived classes to change their behavior.</li>
        <li>If a virtual function is called using a pointer or reference, the version corresponding to the actual object type is executed, not the pointer/reference type.</li>
    </ul>

    <h3>2. Virtual Destructors</h3>
    <p>A <b>virtual destructor</b> is similar to a virtual function but is specifically designed for destructors. A virtual destructor ensures that the derived class's destructor is called when an object is deleted through a base class pointer. This is critical for proper cleanup of resources and avoiding memory leaks, especially when working with polymorphism and dynamic memory allocation.</p>

    <h4>Why use Virtual Destructors?</h4>
    <p>When you delete a derived class object using a base class pointer, the base class destructor would normally be called. This can lead to resource leaks because the derived class's destructor may not be called to clean up any resources it may have allocated. By making the destructor virtual, you ensure that both the base and derived class destructors are invoked in the correct order, ensuring proper memory management.</p>

    <h4>Example: Virtual Destructor</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    // Virtual destructor
    virtual ~Base() {
        cout &lt;&lt; "Base class destructor called" &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        cout &lt;&lt; "Derived class destructor called" &lt;&lt; endl;
    }
};

int main() {
    Base* basePtr = new Derived;

    // Deleting base class pointer that points to derived class object
    delete basePtr;  // Calls the destructor of Derived class first, then Base class

    return 0;
}
    </pre>
    <p>In the above example, we declare a virtual destructor in the <code>Base</code> class. When a <code>Base</code> pointer (<code>basePtr</code>) is used to delete a dynamically allocated object of the <code>Derived</code> class, both the <code>Derived</code> class's destructor and the <code>Base</code> class's destructor are called. Without the virtual destructor, only the base class's destructor would be called, leading to potential memory leaks and improper cleanup.</p>

    <h4>Important Notes about Virtual Destructors:</h4>
    <ul>
        <li>The base class destructor should be made virtual if you plan to delete derived class objects using base class pointers.</li>
        <li>If a virtual destructor is not used, only the base class destructor will be called, and the derived class destructor will not be executed, possibly leading to memory leaks.</li>
        <li>It is a good practice to declare destructors as virtual in base classes when polymorphism is involved, particularly in inheritance hierarchies.</li>
    </ul>

    <h3>Key Differences between Virtual Functions and Virtual Destructors:</h3>
    <ul>
        <li><b>Virtual Functions</b>: Enable polymorphism and allow runtime determination of which function to invoke.</li>
        <li><b>Virtual Destructors</b>: Ensure proper cleanup of resources when objects are deleted through base class pointers.</li>
        <li>Both virtual functions and virtual destructors are essential for ensuring correct behavior in polymorphic class hierarchies.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Virtual functions and virtual destructors are important features of C++ that allow for dynamic polymorphism and proper memory management. Virtual functions enable a flexible and extensible design, while virtual destructors are crucial for avoiding memory leaks in object-oriented systems. Proper use of both ensures that objects are correctly cleaned up and that the correct behavior is invoked at runtime.</p>
</div>

<div class="section" id="friend-functions">
    <h2>Friend Functions in C++</h2>

    <h3>What is a Friend Function?</h3>
    <p>A <b>friend function</b> is a function that is allowed to access the private and protected members of a class, even though it is not a member of that class. This is useful when you need a non-member function to perform operations involving the class's private data.</p>

    <h4>Example of Friend Function</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Box {
private:
    double width;
public:
    Box(double w) : width(w) {}

    // Declare the friend function
    friend void printWidth(Box b);
};

// Friend function definition
void printWidth(Box b) {
    cout &lt;&lt; "Width of the box: " &lt;&lt; b.width &lt;&lt; endl;
}

int main() {
    Box box(10);
    
    // Calling the friend function
    printWidth(box);
    
    return 0;
}
    </pre>

    <h3>Explanation of the Example:</h3>
    <p>In the example above, the class <code>Box</code> has a private member <code>width</code>. The function <code>printWidth()</code> is declared as a friend of the <code>Box</code> class. This allows <code>printWidth()</code> to access the private member <code>width</code> of a <code>Box</code> object, even though it is not a member of the class.</p>

    <h3>Key Points:</h3>
    <ul>
        <li>Friend functions are not members of a class, but they can access private and protected members.</li>
        <li>A friend function must be declared inside the class with the <code>friend</code> keyword.</li>
        <li>Friend functions can be standalone functions or member functions of other classes.</li>
        <li>Friendship is not reciprocal. If Class A declares a function as a friend, it does not mean Class B can declare it as a friend as well.</li>
    </ul>

    <h3>Friend Function vs Member Function:</h3>
    <p><b>Friend Function:</b> Can access private and protected data of a class but is not a member of the class.<br/>
       <b>Member Function:</b> Is a part of the class and can access all its members, including private and protected ones.</p>

    <h3>Friend Functions in Operator Overloading:</h3>
    <p>Friend functions are often used for operator overloading. This is because operators need to access the private members of the class, and friend functions are allowed to do so.</p>

    <h4>Example of Overloading <code>+</code> Operator Using Friend Function:</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

class Complex {
private:
    int real, imag;
public:
    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // Declare friend function to overload the '+' operator
    friend Complex operator + (Complex c1, Complex c2);

    void display() {
        cout &lt;&lt; "Real: " &lt;&lt; real &lt;&lt; ", Imaginary: " &lt;&lt; imag &lt;&lt; endl;
    }
};

// Friend function definition to overload '+' operator
Complex operator + (Complex c1, Complex c2) {
    return Complex(c1.real + c2.real, c1.imag + c2.imag);
}

int main() {
    Complex c1(3, 4), c2(1, 2);
    Complex c3 = c1 + c2;  // Using overloaded '+' operator

    c3.display();
    
    return 0;
}
    </pre>

    <h3>Explanation:</h3>
    <p>In the example above, the <code>+ </code> operator is overloaded using a friend function. The operator allows adding two complex numbers. The friend function has access to the private members <code>real</code> and <code>imag</code> of both <code>Complex</code> objects, even though it is not a member of the class.</p>

    <h3>When to Use Friend Functions?</h3>
    <ul>
        <li>When two or more classes need to work closely with each other and share private data.</li>
        <li>When a function needs access to multiple classesâ€™ private members.</li>
        <li>When implementing operator overloading that involves private data from different classes.</li>
    </ul>
</div>

<div class="section" id="exception-handling">
    <h2>Exception Handling in C++</h2>

    <h3>What is Exception Handling?</h3>
    <p>Exception handling in C++ allows you to catch and handle runtime errors (exceptions) using <code>try</code>, <code>throw</code>, and <code>catch</code> blocks. It helps ensure the program doesn't terminate unexpectedly due to errors.</p>

    <h4>Example of Exception Handling</h4>
    <pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

using namespace std;

void divide(int a, int b) {
    if (b == 0) {
        throw runtime_error("Division by zero is not allowed");
    }
    cout &lt;&lt; "Result: " &lt;&lt; a / b &lt;&lt; endl;
}

int main() {
    try {
        divide(10, 0);  // This will throw an exception
    } catch (const runtime_error &e) {
        cout &lt;&lt; "Caught an exception: " &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>Explanation of the Example:</h3>
    <p>In the above example, the function <code>divide()</code> throws an exception when division by zero is attempted. The exception is caught in the <code>catch</code> block, where the message of the exception is displayed.</p>

    <h3>Key Concepts:</h3>
    <ul>
        <li><b>Try Block:</b> Contains the code that might throw an exception.</li>
        <li><b>Throw Keyword:</b> Used to throw an exception (e.g., <code>throw runtime_error("message");</code>).</li>
        <li><b>Catch Block:</b> Catches and handles the exception thrown by the <code>try</code> block.</li>
    </ul>

    <h3>Multiple Catch Blocks:</h3>
    <p>You can have multiple <code>catch</code> blocks to handle different types of exceptions. The exception type should match the one thrown.</p>

    <h4>Example with Multiple Catch Blocks:</h4>
    <pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

void testFunction(int x) {
    if (x == 0) {
        throw runtime_error("Zero value not allowed");
    } else if (x < 0) {
        throw invalid_argument("Negative value not allowed");
    } else {
        cout &lt;&lt; "Value is valid" &lt;&lt; endl;
    }
}

int main() {
    try {
        testFunction(0);  // This will throw runtime_error
    } catch (const runtime_error &e) {
        cout &lt;&lt; "Caught exception: " &lt;&lt; e.what() &lt;&lt; endl;
    } catch (const invalid_argument &e) {
        cout &lt;&lt; "Caught exception: " &lt;&lt; e.what() &lt;&lt; endl;
    } catch (...) {
        cout &lt;&lt; "Caught an unknown exception" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>Explanation of Multiple Catch Blocks:</h3>
    <p>In this example, the function <code>testFunction()</code> can throw two different types of exceptions: <code>runtime_error</code> and <code>invalid_argument</code>. Depending on the value passed, the corresponding <code>catch</code> block will handle the exception.</p>

    <h3>Catch-All Handler:</h3>
    <p>The <code>catch (...)</code> block is used to catch any exception, including those not specifically handled by other catch blocks. This is useful when you want to handle unexpected or unknown exceptions.</p>

    <h4>Example of Catch-All Handler:</h4>
    <pre>
#include &lt;iostream&gt;
using namespace std;

void someFunction() {
    throw "Unknown error";
}

int main() {
    try {
        someFunction();  // Throws a string exception
    } catch (const char* msg) {
        cout &lt;&lt; "Caught an exception: " &lt;&lt; msg &lt;&lt; endl;
    } catch (...) {
        cout &lt;&lt; "Caught an unknown exception" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>What Happens if No Catch Block is Found?</h3>
    <p>If an exception is thrown and no matching <code>catch</code> block is found, the exception will be propagated to the calling function, and eventually to the operating system if not caught. The program may terminate if the exception is not handled anywhere.</p>

    <h3>Re-throwing Exceptions:</h3>
    <p>You can re-throw an exception caught in a <code>catch</code> block using the <code>throw;</code> statement. This allows an exception to be passed to higher levels of the program.</p>

    <h4>Example of Re-throwing an Exception:</h4>
    <pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

void function1() {
    try {
        throw runtime_error("Error in function1");
    } catch (const runtime_error& e) {
        cout &lt;&lt; "Caught in function1: " &lt;&lt; e.what() &lt;&lt; endl;
        throw;  // Re-throwing the exception
    }
}

int main() {
    try {
        function1();
    } catch (const runtime_error& e) {
        cout &lt;&lt; "Caught in main: " &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>Explanation of Re-throwing:</h3>
    <p>In the above example, the exception is thrown in <code>function1()</code> and caught in its <code>catch</code> block. The exception is then re-thrown using <code>throw;</code> and caught again in the <code>main()</code> function.</p>
</div>

<div class="section" id="file-handling">
    <h2>File Handling in C++</h2>
    <p>File handling in C++ allows us to create, read, write, and manipulate files on the system. C++ provides a set of classes and functions in the <code>fstream</code> library for file operations.</p>

    <h3>Key File Handling Classes in C++</h3>
    <ul>
        <li><b><code>ifstream</code>:</b> Used to read data from a file (input stream).</li>
        <li><b><code>ofstream</code>:</b> Used to write data to a file (output stream).</li>
        <li><b><code>fstream</code>:</b> Used for both reading and writing (input-output stream).</li>
    </ul>

    <h3>Including Header File</h3>
    <p>To work with file handling in C++, include the <code>&lt;fstream&gt;</code> header file.</p>
    <pre>#include &lt;fstream&gt;</pre>

    <h3>File Modes</h3>
    <p>When opening a file, you can specify the mode of operation using the following flags:</p>
    <ul>
        <li><code>ios::in</code>: Open file for reading.</li>
        <li><code>ios::out</code>: Open file for writing.</li>
        <li><code>ios::app</code>: Open file for appending (write at the end).</li>
        <li><code>ios::ate</code>: Open file and move the pointer to the end.</li>
        <li><code>ios::trunc</code>: Delete the content of the file if it exists.</li>
        <li><code>ios::binary</code>: Open file in binary mode.</li>
    </ul>

    <h3>Basic File Operations</h3>

    <h4>1. Creating and Writing to a File</h4>
    <p>Use <code>ofstream</code> to write data to a file.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main() {
    ofstream outFile("example.txt");  // Open file for writing
    if (outFile.is_open()) {
        outFile &lt;&lt; "Hello, File Handling in C++!" &lt;&lt; endl;
        outFile &lt;&lt; "This is a sample text." &lt;&lt; endl;
        outFile.close();  // Close the file
        cout &lt;&lt; "Data written to file successfully!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Error: Unable to open file!" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h4>2. Reading from a File</h4>
    <p>Use <code>ifstream</code> to read data from a file.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main() {
    ifstream inFile("example.txt");  // Open file for reading
    if (inFile.is_open()) {
        string line;
        while (getline(inFile, line)) {  // Read file line by line
            cout &lt;&lt; line &lt;&lt; endl;
        }
        inFile.close();  // Close the file
    } else {
        cout &lt;&lt; "Error: Unable to open file!" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h4>3. Appending to a File</h4>
    <p>Use <code>ofstream</code> with the <code>ios::app</code> mode to append data to a file.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main() {
    ofstream outFile("example.txt", ios::app);  // Open file in append mode
    if (outFile.is_open()) {
        outFile &lt;&lt; "Appending more text to the file." &lt;&lt; endl;
        outFile.close();
        cout &lt;&lt; "Data appended successfully!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Error: Unable to open file!" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h4>4. Reading and Writing to a File</h4>
    <p>Use <code>fstream</code> to perform both read and write operations.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main() {
    fstream file("example.txt", ios::in | ios::out | ios::app);  // Open file for both read and write
    if (file.is_open()) {
        // Writing to the file
        file &lt;&lt; "Using fstream for both reading and writing." &lt;&lt; endl;

        // Move the file pointer to the beginning
        file.seekg(0, ios::beg);

        // Reading from the file
        string line;
        while (getline(file, line)) {
            cout &lt;&lt; line &lt;&lt; endl;
        }

        file.close();  // Close the file
    } else {
        cout &lt;&lt; "Error: Unable to open file!" &lt;&lt; endl;
    }
    return 0;
}
    </pre>

    <h3>Checking File State</h3>
    <p>C++ provides member functions to check the state of a file:</p>
    <ul>
        <li><code>is_open()</code>: Checks if the file is open.</li>
        <li><code>eof()</code>: Checks if the end of file is reached.</li>
        <li><code>fail()</code>: Checks if the last operation failed.</li>
        <li><code>bad()</code>: Checks if the file is in a bad state.</li>
    </ul>

    <h3>Binary File Operations</h3>
    <p>Binary files store data in binary (non-readable) format. Use <code>ios::binary</code> mode for binary file operations.</p>
    <h4>Example: Writing and Reading Binary Data</h4>
    <pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

struct Student {
    char name[50];
    int age;
    float marks;
};

int main() {
    Student s = {"John Doe", 20, 85.5};

    // Writing to a binary file
    ofstream outFile("student.dat", ios::binary);
    if (outFile.is_open()) {
        outFile.write(reinterpret_cast&lt;char*&gt;(&s), sizeof(s));
        outFile.close();
        cout &lt;&lt; "Binary data written successfully!" &lt;&lt; endl;
    }

    // Reading from a binary file
    ifstream inFile("student.dat", ios::binary);
    if (inFile.is_open()) {
        Student readStudent;
        inFile.read(reinterpret_cast&lt;char*&gt;(&readStudent), sizeof(readStudent));
        inFile.close();
        cout &lt;&lt; "Read Data:" &lt;&lt; endl;
        cout &lt;&lt; "Name: " &lt;&lt; readStudent.name &lt;&lt; endl;
        cout &lt;&lt; "Age: " &lt;&lt; readStudent.age &lt;&lt; endl;
        cout &lt;&lt; "Marks: " &lt;&lt; readStudent.marks &lt;&lt; endl;
    }

    return 0;
}
    </pre>

    <h3>Important Points to Remember</h3>
    <ul>
        <li>Always close files after performing operations to avoid data corruption.</li>
        <li>Use <code>ios::binary</code> for binary file operations.</li>
        <li>Check file states using functions like <code>is_open()</code>, <code>eof()</code>, etc.</li>
        <li>Handle exceptions using try-catch blocks for error handling.</li>
    </ul>
</div>
<div class="section" id="stl">
    <h2>Standard Template Library (STL) in C++</h2>
    <p>The Standard Template Library (STL) in C++ is a collection of generic classes and functions that provide commonly used data structures and algorithms. It allows developers to write reusable, efficient, and robust code.</p>

    <h3>Components of STL</h3>
    <p>STL is divided into four main components:</p>
    <ol>
        <li><b>Containers:</b> Used to store and organize data efficiently.</li>
        <li><b>Iterators:</b> Used to traverse elements in containers.</li>
        <li><b>Algorithms:</b> Provide common operations like searching, sorting, and manipulating data.</li>
        <li><b>Functions:</b> Provide predefined functional objects and lambda expressions.</li>
    </ol>

    <h3>1. Containers</h3>
    <p>Containers are objects that store a collection of data. They are classified into three types:</p>

    <h4>Sequence Containers</h4>
    <p>Store data in a linear sequence.</p>
    <ul>
        <li><b>Vector:</b> Dynamic array with random access. <code>#include &lt;vector&gt;</code></li>
        <li><b>Deque:</b> Double-ended queue for insertion/deletion at both ends. <code>#include &lt;deque&gt;</code></li>
        <li><b>List:</b> Doubly linked list for fast insertion and deletion. <code>#include &lt;list&gt;</code></li>
        <li><b>Forward List:</b> Singly linked list. <code>#include &lt;forward_list&gt;</code></li>
        <li><b>Array:</b> Static array of fixed size. <code>#include &lt;array&gt;</code></li>
    </ul>

    <h4>Associative Containers</h4>
    <p>Store data in key-value pairs using a tree structure.</p>
    <ul>
        <li><b>Set:</b> Stores unique elements in sorted order. <code>#include &lt;set&gt;</code></li>
        <li><b>Multiset:</b> Allows duplicate elements in sorted order. <code>#include &lt;set&gt;</code></li>
        <li><b>Map:</b> Key-value pairs with unique keys in sorted order. <code>#include &lt;map&gt;</code></li>
        <li><b>Multimap:</b> Allows duplicate keys in sorted order. <code>#include &lt;map&gt;</code></li>
    </ul>

    <h4>Unordered Containers</h4>
    <p>Store data in hash tables for faster access (not sorted).</p>
    <ul>
        <li><b>Unordered Set:</b> Unique elements in any order. <code>#include &lt;unordered_set&gt;</code></li>
        <li><b>Unordered Multiset:</b> Allows duplicate elements in any order. <code>#include &lt;unordered_set&gt;</code></li>
        <li><b>Unordered Map:</b> Key-value pairs with unique keys in any order. <code>#include &lt;unordered_map&gt;</code></li>
        <li><b>Unordered Multimap:</b> Allows duplicate keys in any order. <code>#include &lt;unordered_map&gt;</code></li>
    </ul>

    <h4>Container Adapters</h4>
    <p>Provide a restricted interface to sequence containers.</p>
    <ul>
        <li><b>Stack:</b> Last In First Out (LIFO). <code>#include &lt;stack&gt;</code></li>
        <li><b>Queue:</b> First In First Out (FIFO). <code>#include &lt;queue&gt;</code></li>
        <li><b>Priority Queue:</b> Elements sorted by priority. <code>#include &lt;queue&gt;</code></li>
    </ul>

    <h3>2. Iterators</h3>
    <p>Iterators are used to access elements in containers. Common types of iterators include:</p>
    <ul>
        <li><b>Input Iterator:</b> Reads elements.</li>
        <li><b>Output Iterator:</b> Writes elements.</li>
        <li><b>Forward Iterator:</b> Moves forward in a single direction.</li>
        <li><b>Bidirectional Iterator:</b> Moves forward and backward.</li>
        <li><b>Random Access Iterator:</b> Provides direct access to elements.</li>
    </ul>
    <p>Iterators can be used with loops like <code>for</code> or <code>while</code> to traverse container elements.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    vector&lt;int&gt;::iterator it;

    for (it = vec.begin(); it != vec.end(); ++it) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}
    </pre>

    <h3>3. Algorithms</h3>
    <p>STL provides a wide range of algorithms to perform operations on containers. The <code>&lt;algorithm&gt;</code> header includes these functions.</p>

    <h4>Common Algorithms</h4>
    <ul>
        <li><b>Sort:</b> <code>sort(vec.begin(), vec.end());</code></li>
        <li><b>Reverse:</b> <code>reverse(vec.begin(), vec.end());</code></li>
        <li><b>Find:</b> <code>find(vec.begin(), vec.end(), value);</code></li>
        <li><b>Max/Min Element:</b> <code>max_element(vec.begin(), vec.end());</code>, <code>min_element(vec.begin(), vec.end());</code></li>
        <li><b>Accumulate:</b> <code>accumulate(vec.begin(), vec.end(), 0);</code></li>
        <li><b>Count:</b> <code>count(vec.begin(), vec.end(), value);</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    vector&lt;int&gt; vec = {10, 20, 30, 40, 50};

    // Sorting
    sort(vec.begin(), vec.end());
    cout &lt;&lt; "Sorted: ";
    for (int x : vec) cout &lt;&lt; x &lt;&lt; " ";

    // Finding Maximum
    cout &lt;&lt; "\nMax: " &lt;&lt; *max_element(vec.begin(), vec.end()) &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>4. Functional Objects (Functors)</h3>
    <p>Functors are objects that act like functions. They can be used with STL algorithms.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Multiply {
    int operator()(int x) const {
        return x * 2;
    }
};

int main() {
    vector&lt;int&gt; vec = {1, 2, 3, 4};
    transform(vec.begin(), vec.end(), vec.begin(), Multiply());

    for (int x : vec) cout &lt;&lt; x &lt;&lt; " ";
    return 0;
}
    </pre>

    <h3>Important Points</h3>
    <ul>
        <li>STL makes programming easier and more efficient by providing reusable components.</li>
        <li>It supports both sequential and associative containers.</li>
        <li>Use iterators and algorithms for cleaner and more readable code.</li>
    </ul>
</div>
<div class="section" id="stl-containers">
    <h2>STL Containers: Vectors, Lists, Stacks, Queues, and Maps</h2>
    <p>STL provides various types of containers to store and manipulate data. These include dynamic arrays, linked lists, stacks, queues, and associative containers like maps.</p>

    <h3>1. Vectors</h3>
    <p>A vector is a dynamic array that can resize itself automatically. It provides random access to elements.</p>
    <ul>
        <li><b>Header:</b> <code>#include &lt;vector&gt;</code></li>
        <li><b>Common Functions:</b> <code>push_back()</code>, <code>pop_back()</code>, <code>size()</code>, <code>capacity()</code>, <code>resize()</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; vec = {1, 2, 3};

    // Adding elements
    vec.push_back(4);
    vec.push_back(5);

    // Display elements
    cout &lt;&lt; "Vector: ";
    for (int x : vec) cout &lt;&lt; x &lt;&lt; " ";

    // Removing the last element
    vec.pop_back();

    cout &lt;&lt; "\nAfter pop_back: ";
    for (int x : vec) cout &lt;&lt; x &lt;&lt; " ";

    return 0;
}
    </pre>

    <h3>2. Lists</h3>
    <p>A list is a doubly linked list that allows efficient insertion and deletion at any position.</p>
    <ul>
        <li><b>Header:</b> <code>#include &lt;list&gt;</code></li>
        <li><b>Common Functions:</b> <code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, <code>pop_front()</code>, <code>insert()</code>, <code>remove()</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

using namespace std;

int main() {
    list&lt;int&gt; lst = {10, 20, 30};

    // Adding elements
    lst.push_back(40);
    lst.push_front(5);

    // Display elements
    cout &lt;&lt; "List: ";
    for (int x : lst) cout &lt;&lt; x &lt;&lt; " ";

    // Removing elements
    lst.pop_front();
    lst.pop_back();

    cout &lt;&lt; "\nAfter pop operations: ";
    for (int x : lst) cout &lt;&lt; x &lt;&lt; " ";

    return 0;
}
    </pre>

    <h3>3. Stacks</h3>
    <p>A stack is a container adapter that follows the Last In First Out (LIFO) principle.</p>
    <ul>
        <li><b>Header:</b> <code>#include &lt;stack&gt;</code></li>
        <li><b>Common Functions:</b> <code>push()</code>, <code>pop()</code>, <code>top()</code>, <code>size()</code>, <code>empty()</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
    stack&lt;int&gt; stk;

    // Push elements
    stk.push(1);
    stk.push(2);
    stk.push(3);

    // Display top element
    cout &lt;&lt; "Top: " &lt;&lt; stk.top() &lt;&lt; endl;

    // Pop element
    stk.pop();
    cout &lt;&lt; "Top after pop: " &lt;&lt; stk.top() &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>4. Queues</h3>
    <p>A queue is a container adapter that follows the First In First Out (FIFO) principle.</p>
    <ul>
        <li><b>Header:</b> <code>#include &lt;queue&gt;</code></li>
        <li><b>Common Functions:</b> <code>push()</code>, <code>pop()</code>, <code>front()</code>, <code>back()</code>, <code>size()</code>, <code>empty()</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
    queue&lt;int&gt; q;

    // Push elements
    q.push(10);
    q.push(20);
    q.push(30);

    // Display front and back elements
    cout &lt;&lt; "Front: " &lt;&lt; q.front() &lt;&lt; ", Back: " &lt;&lt; q.back() &lt;&lt; endl;

    // Pop element
    q.pop();
    cout &lt;&lt; "After pop, Front: " &lt;&lt; q.front() &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>5. Maps</h3>
    <p>A map is an associative container that stores key-value pairs in sorted order of keys.</p>
    <ul>
        <li><b>Header:</b> <code>#include &lt;map&gt;</code></li>
        <li><b>Common Functions:</b> <code>insert()</code>, <code>erase()</code>, <code>find()</code>, <code>count()</code>, <code>size()</code></li>
    </ul>
    <pre>
#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

int main() {
    map&lt;string, int&gt; marks;

    // Insert elements
    marks["Alice"] = 95;
    marks["Bob"] = 89;
    marks["Charlie"] = 92;

    // Display elements
    cout &lt;&lt; "Marks:" &lt;&lt; endl;
    for (auto &pair : marks) {
        cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; endl;
    }

    // Find an element
    string name = "Bob";
    if (marks.find(name) != marks.end()) {
        cout &lt;&lt; name &lt;&lt; "'s marks: " &lt;&lt; marks[name] &lt;&lt; endl;
    }

    return 0;
}
    </pre>

    <h3>6. Summary</h3>
    <p>Each container in STL has specific use cases:</p>
    <ul>
        <li><b>Vector:</b> Use when you need dynamic resizing and random access.</li>
        <li><b>List:</b> Use when you frequently insert or delete elements in the middle.</li>
        <li><b>Stack:</b> Use for LIFO operations (e.g., function calls).</li>
        <li><b>Queue:</b> Use for FIFO operations (e.g., task scheduling).</li>
        <li><b>Map:</b> Use to store and retrieve data using keys.</li>
    </ul>
</div>
<div class="section" id="lambda-expressions">
    <h2>Lambda Expressions in C++</h2>
    <p>Lambda expressions are anonymous functions (functions without a name) that are defined inline. They are used for short, simple tasks, especially when working with algorithms or functional programming constructs.</p>
    
    <h3>Syntax</h3>
    <pre>
[capture-list](parameters) -> return-type { body }
    </pre>
    <ul>
        <li><b>Capture List:</b> Specifies which variables (from the enclosing scope) the lambda can access. Examples: <code>[]</code>, <code>[x]</code>, <code>[&x]</code>, <code>[=]</code>, <code>[&]</code>.</li>
        <li><b>Parameters:</b> Specifies the arguments the lambda accepts (just like a normal function).</li>
        <li><b>Return Type:</b> (Optional) Specifies the return type of the lambda. If omitted, it is deduced automatically.</li>
        <li><b>Body:</b> The code to execute when the lambda is called.</li>
    </ul>

    <h3>Example 1: Basic Lambda Expression</h3>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    // A simple lambda that adds two numbers
    auto add = [](int a, int b) { return a + b; };

    cout &lt;&lt; "Sum: " &lt;&lt; add(5, 10) &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>Example 2: Capturing Variables</h3>
    <p>Variables from the enclosing scope can be captured by value (<code>=</code>) or by reference (<code>&amp;</code>).</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    int x = 5, y = 10;

    // Capture by value
    auto captureByValue = [=]() { return x + y; };

    // Capture by reference
    auto captureByReference = [&]() { x++; y++; return x + y; };

    cout &lt;&lt; "Capture by value: " &lt;&lt; captureByValue() &lt;&lt; endl;

    cout &lt;&lt; "Capture by reference: " &lt;&lt; captureByReference() &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>Example 3: Using Lambda with STL Algorithms</h3>
    <p>Lambdas are often used with STL algorithms like <code>std::sort</code> or <code>std::for_each</code>.</p>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    vector&lt;int&gt; numbers = {4, 2, 8, 6, 1};

    // Sorting in ascending order using a lambda
    sort(numbers.begin(), numbers.end(), [](int a, int b) { return a &lt; b; });

    cout &lt;&lt; "Sorted Numbers: ";
    for (int num : numbers) cout &lt;&lt; num &lt;&lt; " ";

    return 0;
}
    </pre>

    <h3>Example 4: Returning a Lambda</h3>
    <p>Lambdas can be returned from functions.</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

// Function returning a lambda
auto multiplyBy(int factor) {
    return [factor](int value) { return factor * value; };
}

int main() {
    auto multiplyBy2 = multiplyBy(2);

    cout &lt;&lt; "10 * 2 = " &lt;&lt; multiplyBy2(10) &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>Example 5: Specifying Return Type</h3>
    <p>The return type can be explicitly specified if needed.</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    // A lambda with an explicit return type
    auto divide = [](int a, int b) -> double {
        if (b == 0) return 0.0; // Handle division by zero
        return static_cast&lt;double&gt;(a) / b;
    };

    cout &lt;&lt; "10 / 3 = " &lt;&lt; divide(10, 3) &lt;&lt; endl;

    return 0;
}
    </pre>

    <h3>Key Points</h3>
    <ul>
        <li>Lambdas are commonly used in place of small, reusable functions.</li>
        <li>Capture lists allow lambdas to access variables in the enclosing scope.</li>
        <li>They are extremely powerful when working with STL algorithms for concise and readable code.</li>
        <li>Return types are usually deduced but can be explicitly specified if needed.</li>
    </ul>
</div>

<div class="section" id="type-casting">
    <h2>Type Casting in C++</h2>
    <p>Type casting is the process of converting a variable from one data type to another. In C++, there are several ways to perform type casting, categorized into C-style casting and C++-specific casts.</p>

    <h3>1. C-Style Casting</h3>
    <p>C-style casting is the traditional way to cast in C and is also supported in C++. The syntax is:</p>
    <pre>(new_type) expression;</pre>
    <p>Example:</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    double pi = 3.14159;
    int integerPi = (int)pi; // C-style cast

    cout &lt;&lt; "Original value: " &lt;&lt; pi &lt;&lt; endl;
    cout &lt;&lt; "After casting: " &lt;&lt; integerPi &lt;&lt; endl;

    return 0;
}
    </pre>
    <p><b>Disadvantage:</b> It's less explicit and doesn't convey the intent of the cast, leading to potential misuse.</p>

    <h3>2. C++-Specific Casts</h3>
    <p>C++ provides four distinct types of casts to make type conversions more explicit and safer.</p>

    <h4>2.1 <code>static_cast</code></h4>
    <p>Used for compile-time type conversions between related types (e.g., int to double).</p>
    <p><b>Syntax:</b> <code>static_cast&lt;new_type&gt;(expression);</code></p>
    <p>Example:</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    double pi = 3.14159;
    int integerPi = static_cast&lt;int&gt;(pi);

    cout &lt;&lt; "Static cast result: " &lt;&lt; integerPi &lt;&lt; endl;

    return 0;
}
    </pre>
    <p><b>Key Points:</b> Used for safe and predictable conversions, like numeric or pointer upcasts.</p>

    <h4>2.2 <code>dynamic_cast</code></h4>
    <p>Used for runtime type checking and casting of polymorphic types (classes with virtual functions).</p>
    <p><b>Syntax:</b> <code>dynamic_cast&lt;new_type&gt;(expression);</code></p>
    <p>Example:</p>
    <pre>
#include &lt;iostream&gt;

class Base {
public:
    virtual void show() {}
};

class Derived : public Base {
public:
    void show() { std::cout &lt;&lt; "Derived class" &lt;&lt; std::endl; }
};

int main() {
    Base* basePtr = new Derived;
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);

    if (derivedPtr) derivedPtr-&gt;show();
    else std::cout &lt;&lt; "Dynamic cast failed!" &lt;&lt; std::endl;

    delete basePtr;
    return 0;
}
    </pre>
    <p><b>Key Points:</b> Returns <code>nullptr</code> if the cast is not valid, ensuring safe downcasting.</p>

    <h4>2.3 <code>const_cast</code></h4>
    <p>Used to add or remove <code>const</code> or <code>volatile</code> qualifiers.</p>
    <p><b>Syntax:</b> <code>const_cast&lt;new_type&gt;(expression);</code></p>
    <p>Example:</p>
    <pre>
#include &lt;iostream&gt;

void printValue(const int* value) {
    int* nonConstValue = const_cast&lt;int*&gt;(value);
    *nonConstValue = 100; // Modifying value
    std::cout &lt;&lt; "Value: " &lt;&lt; *nonConstValue &lt;&lt; std::endl;
}

int main() {
    int x = 50;
    printValue(&x);
    return 0;
}
    </pre>
    <p><b>Key Points:</b> Should be used cautiously, as it breaks the immutability promise of <code>const</code>.</p>

    <h4>2.4 <code>reinterpret_cast</code></h4>
    <p>Used for low-level type conversion, such as converting between unrelated pointer types.</p>
    <p><b>Syntax:</b> <code>reinterpret_cast&lt;new_type&gt;(expression);</code></p>
    <p>Example:</p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
    int num = 42;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&num);

    cout &lt;&lt; "Reinterpreted value: " &lt;&lt; *charPtr &lt;&lt; endl;

    return 0;
}
    </pre>
    <p><b>Key Points:</b> Can result in undefined behavior if used incorrectly. Avoid unless absolutely necessary.</p>

    <h3>Comparison of Casts</h3>
    <table border="1">
        <thead>
            <tr>
                <th>Cast</th>
                <th>Use Case</th>
                <th>Safety</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>C-Style Cast</td>
                <td>Quick and generic casting.</td>
                <td>Unsafe and not explicit.</td>
            </tr>
            <tr>
                <td>static_cast</td>
                <td>Compile-time type conversions.</td>
                <td>Safe for predictable type conversions.</td>
            </tr>
            <tr>
                <td>dynamic_cast</td>
                <td>Runtime type-checking for polymorphism.</td>
                <td>Safe but incurs runtime overhead.</td>
            </tr>
            <tr>
                <td>const_cast</td>
                <td>Adding/removing <code>const</code> or <code>volatile</code>.</td>
                <td>Safe but should be used sparingly.</td>
            </tr>
            <tr>
                <td>reinterpret_cast</td>
                <td>Low-level pointer reinterpretation.</td>
                <td>Unsafe, use with caution.</td>
            </tr>
        </tbody>
    </table>
</div>


</div>

    <footer>
        <p>&copy; 2023-2025. SEED Institue Of Training - All rights reserved</p>
    </footer>
</body>
</html>
